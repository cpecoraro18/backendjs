//
//  Author: Vlad Seryakov vseryakov@gmail.com
//  backendjs 2018
//

const lib = require(__dirname + '/lib');
const db = require(__dirname + '/db');
const api = require(__dirname + '/api');

const mod = {
    args: [
        { name: "table", descr: "Table to use for accounts" },
    ],
    table: "bk_auth",
};
module.exports = mod;

mod.configure = function(options, callback)
{
    // We only create the default table if it is used
    if (this.table == "bk_auth") {
        db.describeTables({
            bk_auth: {
                login: { primary: 1 },                                      // Account login/username
                id: { type: "uuid", prefix: "u_", admin: 1, unique: 1 },    // Autogenerated ID
                name: { type: "text" },                                     // Account name
                status: { type: "text" },                                   // Status of the account
                type: { type: "list", list: 1, lower: 1, admin: 1 },        // Account roles: admin, ....
                flags: { type: "list", list: 1 },                           // Tags/flags about the account
                secret: { secure: 1 },                                      // Signature secret or scrambled password
                auth_secret: { admin: 1, secure: 1 },                       // Passcode for 2-factor authentication
                session_secret: { admin: 1, secure: 1 },                    // Secret for session signatures
                rlimits_max: { type: "int", admin: 1 },                     // Burst/max reqs/sec rate allowed for this account, 0 to disable
                rlimits_rate: { type: "int", admin: 1 },                    // Fill/normal reqs/sec rate for this account, 0 to disable
                expires: { type: "bigint", admin: 1, secure: 1 },           // Deny access to the account if this value is before current date, ms
                ctime: { type: "now", readonly: 1 },                        // Create time
                mtime: { type: "now" }
            },
        });
    }

    callback();
}

mod.configureMiddleware = function(options, callback)
{
    // Check the signature, for virtual hosting, supports only the simple case when running the API and static web sites on the same server
    if (!api.noSignature) {
        api.app.use(api.handleSignature.bind(api));
    }

    callback();
}

mod.configureWeb = function(options, callback)
{
    // For health checks
    api.app.all("/ping", function(req, res) {
        api.sendJSON(req, null, {});
    });

    // Authentication check without accounts module
    api.app.all("/auth", function(req, res) {
        if (!req.account || !req.account.id) {
            return api.sendReply(res, { status: 417, message: "No username provided", code: "NOLOGIN" });
        }
        api.handleSessionSignature(req, () => {
            req.options.cleanup = mod.table;
            api.sendJSON(req, null, req.account);
        });
    });

    // Login with just the secret without signature
    api.app.all("/login", function(req, res) {
        if (!req.query.login || !req.query.secret) {
            return api.sendReply(res, { status: 417, message: this.checkErrmsg(req, null, "No username or password provided"), code: "NOLOGIN" });
        }
        // Create internal signature from the login data
        req.signature = api.newSignature(req, "version", -1, "source", "l", "login", req.query.login, "secret", req.query.secret);
        delete req.query.login;
        delete req.query.secret;
        api.checkRequestSignature(req, function(err) {
            if (!req.account || !req.account.id) {
                return api.sendJSON(req, err || { status: 417, message: "No username provided", code: "NOLOGIN" });
            }
            api.handleSessionSignature(req, () => {
                req.options.cleanup = mod.table;
                api.sendJSON(req, null, req.account);
            });
        });
    });

    // Clear sessions and access tokens
    api.app.all("/logout", function(req, res) {
        api.clearSessionSignature(req);
        api.sendJSON(req);
    });

    // Return images by prefix, id and possibly type
    api.app.all(/^\/image\/([a-zA-Z0-9_.:-]+)\/([^/ ]+)\/?([^/ ]+)?$/, function(req, res) {
        var options = api.getOptions(req);
        options.prefix = req.params[0];
        options.type = req.params[2];
        var id = req.params[1];
        // Image extension at the end so it looks like an image path
        if (options.type) {
            const d = options.type.match(/^(.+)\.(png|jpg|jpeg|gif)$/);
            if (d) options.type = d[1], options.ext = d[2];
        } else {
            const d = id.match(/^(.+)\.(png|jpg|jpeg|gif)$/);
            if (d) id = d[1], options.ext = d[2];
        }
        api.sendIcon(req, id, options);
    });

    callback();
}

// If specified in the options, prepare credentials to be stored in the db, if no error occurred return null, otherwise an error object
//  - scramble is used to encrypt the secret with login as HMAC_SHA256 so the db never stores cleartext credentials
//  - bcrypt - use bcrypt module to generate password hash with specified number of salt rounds, recommended value is 10
mod.prepareSecret = function(query, options, callback)
{
    if (!options) options = {};

    if (!query.secret) delete query.secret;

    // Ignore the supplied value, always set with new uuid
    if (query.token_secret) {
        query.token_secret = lib.random();
    }

    if (query.login && query.secret && options.scramble) {
        query.secret = lib.sign(query.secret, query.login, "sha256");
    }

    lib.series([
        function(next) {
            if (!query.secret) return next();
            if (!options.bcrypt) return next();
            if (!api.bcrypt) api.bcrypt = require('bcrypt');
            api.bcrypt.hash(query.secret, lib.toNumber(options.bcrypt), function(err, hash) {
                query.secret = hash;
                next();
            });
        },
        function(next) {
            var hooks = api.findHook('secret', '', query.login);
            if (!hooks.length) return next();
            lib.forEachSeries(hooks, function(hook, next2) {
                hook.callback.call(api, query, options, next2);
            }, next);
        },
    ], callback);
}

mod.isUid = function(id)
{
    return lib.isUuid(id, db.tables.bk_auth.id.prefix);
}

// Returns an account record by login or id
mod.get = function(query, options, callback)
{
    if (typeof options == "function") callback = options, options = null;
    if (typeof query == "string") {
        query = { [this.isUid(query) ? "id" : "login"]: query };
    }
    if (query.login) {
        db.get(this.table, query, callback);
    } else
    if (query.id) {
        db.select(this.table, { id: query.id }, { cacheKeyName: "id", count: 1, first: 1 }, (err, row, info) => {
            if (!row) return callback(err);
            // For databases that do not support all columns with indexes(DynamoDB) we have to re-read by the primary key
            if (row.name && row.mtime) return callback(null, row, info);
            db.get(this.table, { login: row.login }, callback);
        });
    } else {
        callback();
    }
}

// Registers a new account, returns new record in the callback, when options.admin is true then allow to set all properties
// otherwise admin properties will not be added
mod.add = function(query, options, callback)
{
    if (typeof options == "function") callback = options, options = null;
    if (!query.login) return lib.tryCall(callback, { status: 400, message: "The username is required" });
    if (!query.secret) return lib.tryCall(callback, { status: 400, message: "The password is required" });
    if (!query.name) return lib.tryCall(callback, { status: 400, message: "The name is required" });
    options = lib.objClone(options, "result_obj", 1, "first", 1);
    query.token_secret = true;
    this.prepareSecret(query, options, () => {
        if (!(options.admin || api.checkAccountType(options.account, "admin"))) {
            api.clearQuery(this.table, query, "admin");
        }
        delete query.id;
        db.add(this.table, query, options, (err, row, info) => {
            if (!err) for (const p in row) query[p] = row[p];
            lib.tryCall(callback, err, query, info);
        });
    });
}

// Updates an existing account by login or id, if `options.admin` is true then allow to update all properties, returns a new record in the callback
mod.update = function(query, options, callback)
{
    if (typeof options == "function") callback = options, options = null;
    options = lib.objClone(options, "returning", "*", "first", 1);
    this.prepareSecret(query, options, () => {
        if (!(options.admin || api.checkAccountType(options.account, "admin"))) {
            api.clearQuery(this.table, query, "admin");
        }
        if (!query.name) delete query.name;
        if (!this.isUid(query.id)) delete query.id;
        if (query.login) {
            db.update(this.table, query, options, callback);
        } else
        if (query.id) {
            db.select(this.table, { id: query.id }, { cacheKeyName: "id", count: 1, first: 1 }, (err, row) => {
                if (!row) return callback(err, { status: 404, message: "Invalid id provided" });
                query.login = row.login;
                db.update(this.table, query, options, callback);
            });
        } else {
            lib.tryCall(callback, { status: 400, message: "No username or id provided" });
        }
    });
}

// Deletes an existing account by login or id, no admin checks, returns the old record in the callback
mod.del = function(query, options, callback)
{
    if (typeof options == "function") callback = options, options = null;
    if (typeof query == "string") {
        query = { [this.isUid(query) ? "id" : "login"]: query };
    }
    options = lib.objClone(options, "returning", "old", "first", 1);
    if (query.login) {
        db.del(this.table, query, options, callback);
    } else
    if (query.id) {
        db.select(this.table, { id: query.id }, { cacheKeyName: "id", count: 1, first: 1 }, (err, row) => {
            if (!row) return callback(err, { status: 404, message: "Invalid id provided" });
            query.login = row.login;
            db.del(this.table, query, options, callback);
        });
    } else {
        lib.tryCall(callback, { status: 400, message: "No username or id provided" });
    }
}

