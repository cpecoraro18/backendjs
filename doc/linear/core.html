<!DOCTYPE html>

<html>
<head>
  <title>core.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="public/stylesheets/normalize.css" />
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div class="container">
    <div class="page">

      <div class="header">
        
          <h1>core.js</h1>
        

        
          <div class="toc">
            <h3>Table of Contents</h3>
            <ol>
              
                
                <li>
                  <a class="source" href="api.html">
                    api.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="aws.html">
                    aws.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="core.html">
                    core.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="db.html">
                    db.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="index.html">
                    index.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="logger.html">
                    logger.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="server.html">
                    server.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tests.html">
                    tests.js
                  </a>
                </li>
              
            </ol>
          </div>
        
      </div>

      
        
        <p> Author: Vlad Seryakov vseryakov@gmail.com
 Sep 2013</p>

        
          <div class='highlight'><pre><span class="keyword">var</span> util = require(<span class="string">'util'</span>);
<span class="keyword">var</span> fs = require(<span class="string">'fs'</span>);
<span class="keyword">var</span> repl = require(<span class="string">'repl'</span>);
<span class="keyword">var</span> path = require(<span class="string">'path'</span>);
<span class="keyword">var</span> crypto = require(<span class="string">'crypto'</span>);
<span class="keyword">var</span> url = require(<span class="string">'url'</span>);
<span class="keyword">var</span> http = require(<span class="string">'http'</span>);
<span class="keyword">var</span> https = require(<span class="string">'https'</span>);
<span class="keyword">var</span> exec = require(<span class="string">'child_process'</span>).exec;
<span class="keyword">var</span> backend = require(__dirname + <span class="string">'/backend'</span>);
<span class="keyword">var</span> logger = require(__dirname + <span class="string">'/logger'</span>);
<span class="keyword">var</span> cluster = require(<span class="string">'cluster'</span>);
<span class="keyword">var</span> printf = require(<span class="string">'printf'</span>);
<span class="keyword">var</span> async = require(<span class="string">'async'</span>);
<span class="keyword">var</span> os = require(<span class="string">'os'</span>);
<span class="keyword">var</span> emailjs = require(<span class="string">'emailjs'</span>);
<span class="keyword">var</span> memcached = require(<span class="string">'memcached'</span>);
<span class="keyword">var</span> redis = require(<span class="string">"redis"</span>);</pre></div>
        
      
        
        <p>The primary object containing all config options and common functions</p>

        
          <div class='highlight'><pre><span class="keyword">var</span> core = {
    name: <span class="string">'backend'</span>,
    version: <span class="string">'2013.10.20.0'</span>,</pre></div>
        
      
        
        <p>Process and config parameters</p>

        
          <div class='highlight'><pre>    argv: [],</pre></div>
        
      
        
        <p>Server role, used by API server, for provisioning must include backend</p>

        
          <div class='highlight'><pre>    role: <span class="string">''</span>,</pre></div>
        
      
        
        <p>Local domain</p>

        
          <div class='highlight'><pre>    domain: <span class="string">''</span>,</pre></div>
        
      
        
        <p>Instance mode, remote jobs</p>

        
          <div class='highlight'><pre>    instance: <span class="literal">false</span>,</pre></div>
        
      
        
        <p>Home directory, current by default, must be absolute path</p>

        
          <div class='highlight'><pre>    home: process.env.BACKEND_HOME || <span class="string">''</span>,</pre></div>
        
      
        
        <p>Various folders, by default relative paths are used</p>

        
          <div class='highlight'><pre>    path: { etc: <span class="string">"etc"</span>, spool: <span class="string">"var"</span>, images: <span class="string">"images"</span>, tmp: <span class="string">"tmp"</span>, web: <span class="string">"web"</span>, log: <span class="string">"log"</span> },</pre></div>
        
      
        
        <p>Log file for debug and other output from the modules, error or info messages, default is stdout</p>

        
          <div class='highlight'><pre>    logfile: <span class="literal">null</span>,</pre></div>
        
      
        
        <p>HTTP port of the server</p>

        
          <div class='highlight'><pre>    port: <span class="number">80</span>,
    bind: <span class="string">'0.0.0.0'</span>,</pre></div>
        
      
        
        <p>Number of parallel tasks running at the same time, can be used by various modules</p>

        
          <div class='highlight'><pre>    concurrency: <span class="number">2</span>,
    ipaddr: <span class="string">''</span>,
    hostname: <span class="string">''</span>,</pre></div>
        
      
        
        <p>Unix user/group privileges to set after opening port 80 and if running as root, in most cases this is ec2-user on Amazon cloud,
for manual installations rc.backend setup will create a user with this id</p>

        
          <div class='highlight'><pre>    uid: <span class="number">777</span>,
    gid: <span class="number">0</span>,
    umask: <span class="string">'0002'</span>,</pre></div>
        
      
        
        <p>Watched source files for changes, restartes the process if any file has chaged</p>

        
          <div class='highlight'><pre>    watchdirs: [],
    timers: {},</pre></div>
        
      
        
        <p>Log watcher config, watch for server restarts as well</p>

        
          <div class='highlight'><pre>    logwatcherMax: <span class="number">1000000</span>,
    logwatcherInterval: <span class="number">3600</span>,
    logwatcherIgnore: <span class="string">"NOTICE: |DEBUG: |DEV: "</span>,
    logwatcherFiles: [ { file: <span class="string">"/var/log/messages"</span>, match: <span class="regexp">/\[[0-9]+\]: (ERROR|WARNING): |message":"ERROR:|queryAWS:.+Errors:|startServer:|startFrontend:/</span> },
                       { name: <span class="string">"logfile"</span>, match: <span class="regexp">/\[[0-9]+\]: ERROR: |message":"ERROR:|queryAWS:.+Errors:|startServer:|startFrontend:/</span> } ],</pre></div>
        
      
        
        <p>User agent</p>

        
          <div class='highlight'><pre>    userAgent: [<span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:18.0) Gecko/20100101 Firefox/18.0"</span>,
                 <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:21.0) Gecko/20100101 Firefox/21.0"</span>,
                 <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.7; rv:20.0) Gecko/20100101 Firefox/20.0"</span>,
                 <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_3) AppleWebKit/536.29.13 (KHTML, like Gecko) Version/6.0.4 Safari/536.29.13"</span>,
                 <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_3) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.65 Safari/537.31"</span>,
                 <span class="string">"Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.34 (KHTML, like Gecko) Safari/534.34"</span>,
                 <span class="string">"Opera/9.80 (Macintosh; Intel Mac OS X 10.7.5) Presto/2.12.388 Version/12.15"</span>,
                 <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:21.0) Gecko/20100101 Firefox/21.0"</span>,
                 <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/6.0; SLCC2; .NET CLR 2.0.50727"</span>,
                 <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/6.0; SLCC2; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; InfoPath.2; BRI/2"</span>,
                 ],</pre></div>
        
      
        
        <p>Config parameters</p>

        
          <div class='highlight'><pre>    args: [ { name: <span class="string">"debug"</span>, type: <span class="string">"callback"</span>, value: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> logger.setDebug(<span class="string">'debug'</span>); }, descr: <span class="string">"Enable debuggng messages"</span> },
            { name: <span class="string">"log"</span>, type: <span class="string">"callback"</span>, value: <span class="function"><span class="keyword">function</span><span class="params">(v)</span> {</span> logger.setDebug(v); }, descr: <span class="string">"Set debugging level: none, log, debug, dev"</span> },
            { name: <span class="string">"logfile"</span>, type: <span class="string">"callback"</span>, value: <span class="function"><span class="keyword">function</span><span class="params">(v)</span> {</span> logger.setFile(v); }, descr: <span class="string">"File where to write logging messages"</span> },
            { name: <span class="string">"syslog"</span>, type: <span class="string">"callback"</span>, value: <span class="function"><span class="keyword">function</span><span class="params">(v)</span> {</span> logger.setSyslog(v ? <span class="keyword">this</span>.toBool(v) : <span class="literal">true</span>); }, descr: <span class="string">"Write all logging messages to syslog"</span> },
            { name: <span class="string">"console"</span>, type: <span class="string">"callback"</span>, value: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> core.logfile = <span class="literal">null</span>; logger.setFile(<span class="literal">null</span>);}, descr: <span class="string">"All logging goes to the console"</span> },
            { name: <span class="string">"home"</span>, type: <span class="string">"callback"</span>, value: <span class="string">"setHome"</span>, descr: <span class="string">"Specify home directory for the server, current dir if not specified"</span> },
            { name: <span class="string">"concurrency"</span>, type:<span class="string">"number"</span>, min: <span class="number">1</span>, max: <span class="number">4</span>, descr: <span class="string">"How many simultaneous tasks to run att he same time inside one process"</span> },
            { name: <span class="string">"umask"</span>, descr: <span class="string">"Filesystem mask"</span> },
            { name: <span class="string">"uid"</span>, type: <span class="string">"number"</span>, min: <span class="number">0</span>, max: <span class="number">9999</span>, descr: <span class="string">"User id to switch after start if running as root"</span> },
            { name: <span class="string">"gid"</span>, type: <span class="string">"number"</span>, min: <span class="number">0</span>, max: <span class="number">9999</span>, descr: <span class="string">"Group id to switch after start if running to root"</span> },
            { name: <span class="string">"port"</span>, type: <span class="string">"number"</span>, min: <span class="number">0</span>, max: <span class="number">99999</span>, descr: <span class="string">"HTTP port to listen for the server"</span> },
            { name: <span class="string">"bind"</span>, descr: <span class="string">"Bind to this address only, if not specified listen on all interfaces"</span> },
            { name: <span class="string">"repl-port"</span>, type: <span class="string">"number"</span>, min: <span class="number">0</span>, max: <span class="number">99999</span>, descr: <span class="string">"Port for REPL interface server"</span> },
            { name: <span class="string">"repl-bind"</span>, descr: <span class="string">"Listen only on specified address for REPL server"</span> },
            { name: <span class="string">"repl-file"</span>, descr: <span class="string">"User specified file for REPL history"</span> },
            { name: <span class="string">"lru-max"</span>, type: <span class="string">"number"</span>, descr: <span class="string">"Max number of items in the LRU cache"</span> },
            { name: <span class="string">"lru-server"</span>, descr: <span class="string">"LRU server that acts as a NNBUS node to brosadcast cache messages to all connected backends"</span> },
            { name: <span class="string">"lru-host"</span>, descr: <span class="string">"Address of NNBUS servers for cache broadcasts: ipc:///path,tcp://IP:port..."</span> },
            { name: <span class="string">"memcache-host"</span>, type: <span class="string">"list"</span>, descr: <span class="string">"List of memcached servers for cache messages: IP:port,IP:port..."</span> },
            { name: <span class="string">"memcache-options"</span>, type: <span class="string">"json"</span>, descr: <span class="string">"JSON object with options to the Memcached client, see npm doc memcached"</span> },
            { name: <span class="string">"redis-host"</span>, descr: <span class="string">"Address to Redis server for cache messages"</span> },
            { name: <span class="string">"redis-options"</span>, type: <span class="string">"json"</span>, descr: <span class="string">"JSON object with options to the Redis client, see npm doc redis"</span> },
            { name: <span class="string">"cache-type"</span>, descr: <span class="string">"One of the redis or memcache to use for caching in API requests"</span> },
            { name: <span class="string">"no-cache"</span>, type:<span class="string">" bool"</span>, descr: <span class="string">"Do not use LRU server, all gets will result in miss and puts will have no effect"</span> },
            { name: <span class="string">"worker"</span>, type:<span class="string">" bool"</span>, descr: <span class="string">"Set this process as a worker even it is actually a master, this skips some initializations"</span> },
            { name: <span class="string">"logwatcher-email"</span>, descr: <span class="string">"Email for the logwatcher notifications"</span> },
            { name: <span class="string">"logwatcher-from"</span>, descr: <span class="string">"Email to send logwatcher notifications from"</span> },
            { name: <span class="string">"logwatcher-ignore"</span>, descr: <span class="string">"Regexp with patterns that needs to be ignored by logwatcher process"</span> },
            { name: <span class="string">"logwatcher-match"</span>, descr: <span class="string">"Regexp patterns that match conditions for logwatcher notifications"</span> },
            { name: <span class="string">"logwatcher-interval"</span>, type: <span class="string">"number"</span>, min: <span class="number">300</span>, max: <span class="number">86400</span> },
            { name: <span class="string">"user-agent"</span>, type: <span class="string">"push"</span>, descr: <span class="string">"Add HTTP user-agent header to be used in HTTP requests, for scrapers"</span> },
            { name: <span class="string">"backend-host"</span>, descr: <span class="string">"Host of the master backend"</span> },
            { name: <span class="string">"backend-key"</span>, descr: <span class="string">"Credentials key for the master backend access"</span> },
            { name: <span class="string">"backend-secret"</span>, descr: <span class="string">"Credentials secret for the master backend access"</span> },
            { name: <span class="string">"domain"</span>, descr: <span class="string">"Domain to use for communications, default is current domain of the host machine"</span> },
            { name: <span class="string">"instance"</span>, type: <span class="string">"bool"</span>, descr: <span class="string">"enables instance mode, means the backend is runnin on remote instance"</span> },
            { name: <span class="string">"backtrace"</span>, type: <span class="string">"callback"</span>, value: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> backend.setbacktrace(); }, descr: <span class="string">"Enable backtrace fcility, trap crashes and report the backtrace stack"</span> },
            { name: <span class="string">"watch"</span>, type: <span class="string">"callback"</span>, value: <span class="function"><span class="keyword">function</span><span class="params">(v)</span> {</span> <span class="keyword">this</span>.watch = <span class="literal">true</span>; <span class="keyword">this</span>.watchdirs.push(v ? v : __dirname); }, descr: <span class="string">"Watch sources directory for file changes to restart the server, for development"</span> }
    ],</pre></div>
        
      
        
        <p>Inter-process messages</p>

        
          <div class='highlight'><pre>    ipcs: {},
    ipcId: <span class="number">1</span>,
    ipcTimeout: <span class="number">500</span>,
    lruMax: <span class="number">1000</span>,</pre></div>
        
      
        
        <p>REPL port for server</p>

        
          <div class='highlight'><pre>    replPort: <span class="number">2080</span>,
    replBind: <span class="string">'0.0.0.0'</span>,
    replFile: <span class="string">'.history'</span>,
    context: {},</pre></div>
        
      
        
        <p>Main intialization, must be called prior to perform any actions</p>

        
          <div class='highlight'><pre>    init: <span class="function"><span class="keyword">function</span><span class="params">(callback)</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;</pre></div>
        
      
        
        <p>Assume current dir as our home</p>

        
          <div class='highlight'><pre>        self.setHome();</pre></div>
        
      
        
        <p>Find our IP address</p>

        
          <div class='highlight'><pre>        <span class="keyword">var</span> intf = os.networkInterfaces();
        Object.keys(intf).forEach(<span class="function"><span class="keyword">function</span><span class="params">(x)</span> {</span>
            <span class="keyword">if</span> (!self.ipaddr &amp;&amp; x.substr(<span class="number">0</span>, <span class="number">2</span>) != <span class="string">'lo'</span>) {
                intf[x].forEach(<span class="function"><span class="keyword">function</span><span class="params">(y)</span> {</span> <span class="keyword">if</span> (y.family == <span class="string">'IPv4'</span> &amp;&amp; y.address) self.ipaddr = y.address; });
            }
        });</pre></div>
        
      
        
        <p>Default domain from local host name</p>

        
          <div class='highlight'><pre>        <span class="keyword">var</span> host = os.hostname().split(<span class="string">'.'</span>);
        self.hostname = host[<span class="number">0</span>];
        self.domain = host.length &gt; <span class="number">2</span> ? host.slice(<span class="number">1</span>).join(<span class="string">'.'</span>) : self.hostname;

        <span class="keyword">var</span> db = self.context.db;</pre></div>
        
      
        
        <p>Serialize initialization procedure, run each function one after another</p>

        
          <div class='highlight'><pre>        async.series([
            <span class="function"><span class="keyword">function</span><span class="params">(next)</span> {</span>
                self.loadConfig(next);
            },</pre></div>
        
      
        
        <p>Create all directories, only master should do it once but we resolve absolute paths in any mode</p>

        
          <div class='highlight'><pre>            <span class="function"><span class="keyword">function</span><span class="params">(next)</span> {</span>
                self.parseArgs(process.argv);</pre></div>
        
      
        
        <p>Redirect system logging to stderr</p>

        
          <div class='highlight'><pre>                logger.setChannel(<span class="string">"stderr"</span>);
                
                <span class="keyword">try</span> { process.umask(self.umask); } <span class="keyword">catch</span>(e) { logger.error(<span class="string">"umask:"</span>, self.umask, e) }</pre></div>
        
      
        
        <p>Resolve to absolute paths</p>

        
          <div class='highlight'><pre>                <span class="keyword">var</span> files = [];
                Object.keys(self.path).forEach(<span class="function"><span class="keyword">function</span><span class="params">(p)</span> {</span>
                    self[p] = path.resolve(self.path[p]);
                    files.push(self[p]);
                });
                
                <span class="keyword">if</span> (!cluster.isWorker &amp;&amp; !self.worker) {</pre></div>
        
      
        
        <p>Create all subfolders</p>

        
          <div class='highlight'><pre>                    files.forEach(<span class="function"><span class="keyword">function</span><span class="params">(dir)</span> {</span> self.mkdirSync(dir); });</pre></div>
        
      
        
        <p>Make sure created files are owned by regular user, not the root</p>

        
          <div class='highlight'><pre>                    <span class="keyword">if</span> (process.getuid() == <span class="number">0</span>) {
                        files.push(path.join(self.path.spool, self.name + <span class="string">".db"</span>));
                        files.forEach(<span class="function"><span class="keyword">function</span><span class="params">(f)</span> {</span> self.chownSync(f) });
                    }
                }
                db.init(next);
            },

            <span class="function"><span class="keyword">function</span><span class="params">(next)</span> {</span></pre></div>
        
      
        
        <p>Watch config directory for changes</p>

        
          <div class='highlight'><pre>                fs.watch(self.etc, <span class="function"><span class="keyword">function</span> <span class="params">(event, filename)</span> {</span>
                    logger.debug(<span class="string">'watcher:'</span>, event, filename);
                    <span class="keyword">switch</span> (filename) {
                    <span class="keyword">case</span> <span class="string">"config"</span>:
                        self.setTimeout(filename, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> self.loadConfig(); }, <span class="number">5000</span>);
                        <span class="keyword">break</span>;
                    }
                });
                next();
            }],</pre></div>
        
      
        
        <p>Final callbacks</p>

        
          <div class='highlight'><pre>            <span class="function"><span class="keyword">function</span><span class="params">(err)</span> {</span>
                logger.debug(<span class="string">"core: init:"</span>, err || <span class="string">""</span>);
                <span class="keyword">if</span> (callback) setImmediate(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> 
                    callback.call(self, err); 
                });
        });
    },</pre></div>
        
      
        
        <p>Run any backend function after environment has been intialized, this is to be used in shell scripts,
core.init will parse all command line arguments, the simplest case to run from /data directory and it will use
default environment or pass -home dir so the script will reuse same config and paths as the server
context can be specified for the callback, if no then it run in the core context</p>
<ul>
<li>require(&#39;backend&#39;).run(function() {}) is one example where this call is used as a shortcut for ad-hoc scripting</li>
</ul>

        
          <div class='highlight'><pre>    run: <span class="function"><span class="keyword">function</span><span class="params">(callback)</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;
        <span class="keyword">if</span> (!callback) <span class="keyword">return</span> logger.error(<span class="string">'run:'</span>, <span class="string">'callback is required'</span>);
        <span class="keyword">this</span>.init(<span class="function"><span class="keyword">function</span><span class="params">(err)</span> {</span>
            callback.call(self, err);
        });
    },</pre></div>
        
      
        
        <p>Run modules init callbacks, called by master server and all settings will be available for worker processes</p>

        
          <div class='highlight'><pre>    initModules: <span class="function"><span class="keyword">function</span><span class="params">(callback)</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;
        async.forEachSeries(Object.keys(self.context), <span class="function"><span class="keyword">function</span><span class="params">(ctx, next)</span> {</span>
            ctx = self.context[ctx];
            <span class="keyword">if</span> (ctx.initModule) ctx.initModule.call(ctx, next); <span class="keyword">else</span> next();
        }, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            <span class="keyword">if</span> (callback) callback();
        });
    },</pre></div>
        
      
        
        <p>Switch to new home directory, exit if we cannot, this is important for relative paths to work if used,
no need to do this in worker because we already switched to home diretory in the master and all child processes
inherit current directory
Important note: If run with combined server or as a daemon then this MUST be an absolute path, otherwise calling 
it in the spawned web master will fail due to the fact that we already set the home and relative path will not work after that. </p>

        
          <div class='highlight'><pre>    setHome: <span class="function"><span class="keyword">function</span><span class="params">(home)</span> {</span>
        <span class="keyword">if</span> ((home || <span class="keyword">this</span>.home) &amp;&amp; cluster.isMaster) {
            <span class="keyword">if</span> (home) <span class="keyword">this</span>.home = path.resolve(home);
            <span class="keyword">try</span> {
                process.chdir(<span class="keyword">this</span>.home);
            } <span class="keyword">catch</span>(e) {
                logger.error(<span class="string">'setHome: cannot set home directory'</span>, <span class="keyword">this</span>.home, e);
                process.exit(<span class="number">1</span>);
            }
            logger.dev(<span class="string">'setHome:'</span>, <span class="keyword">this</span>.home);
        }
        <span class="keyword">this</span>.home = process.cwd();
    },</pre></div>
        
      
        
        <p>Parse command line arguments</p>

        
          <div class='highlight'><pre>    parseArgs: <span class="function"><span class="keyword">function</span><span class="params">(argv)</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;
        <span class="keyword">if</span> (!argv || !argv.length) <span class="keyword">return</span>;</pre></div>
        
      
        
        <p>Append all process arguments into internal list</p>

        
          <div class='highlight'><pre>        <span class="keyword">this</span>.argv = <span class="keyword">this</span>.argv.concat(argv);</pre></div>
        
      
        
        <p>Convert spaces if passed via command line</p>

        
          <div class='highlight'><pre>        argv = argv.map(<span class="function"><span class="keyword">function</span><span class="params">(x)</span> {</span> <span class="keyword">return</span> x.replace(<span class="regexp">/%20/g</span>, <span class="string">' '</span>) });
        logger.dev(<span class="string">'parseArgs:'</span>, argv.join(<span class="string">' '</span>));</pre></div>
        
      
        
        <p>Special case, display help for all args</p>

        
          <div class='highlight'><pre>        <span class="keyword">if</span> (<span class="keyword">this</span>.argv.indexOf(<span class="string">"--help"</span>) &gt; -<span class="number">1</span>) {
            <span class="keyword">var</span> args = [ [ <span class="string">''</span>, core.args ] ];
            Object.keys(<span class="keyword">this</span>.context).forEach(<span class="function"><span class="keyword">function</span><span class="params">(n)</span> {</span> <span class="keyword">if</span> (self.context[n].args) args.push([n, self.context[n].args]); })
            args.forEach(<span class="function"><span class="keyword">function</span><span class="params">(x)</span> {</span> x[<span class="number">1</span>].forEach(<span class="function"><span class="keyword">function</span><span class="params">(y)</span> {</span> <span class="keyword">if</span> (y.name &amp;&amp; y.descr) console.log(printf(<span class="string">"%-40s"</span>, (x[<span class="number">0</span>] ? x[<span class="number">0</span>] + <span class="string">'-'</span> : <span class="string">''</span>) + y.name), y.descr); }); });
            process.exit(<span class="number">0</span>);
        }</pre></div>
        
      
        
        <p>Core parameters</p>

        
          <div class='highlight'><pre>        self.processArgs(<span class="string">"core"</span>, self, argv);</pre></div>
        
      
        
        <p>Run registered handlers for each module</p>

        
          <div class='highlight'><pre>        <span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">in</span> <span class="keyword">this</span>.context) {
            <span class="keyword">var</span> ctx = <span class="keyword">this</span>.context[n];
            <span class="keyword">if</span> (ctx.parseArgs) ctx.parseArgs.call(ctx, argv);
            self.processArgs(n, ctx, argv);
        }
    },</pre></div>
        
      
        
        <p>Config parameters defined in a module as a list of parameter names prefixed with module name, a parameters can be
a string which defines text parameter or an object with the properties: name, type, value, decimals, min, max, separator
type can be bool, number, list, json</p>

        
          <div class='highlight'><pre>    processArgs: <span class="function"><span class="keyword">function</span><span class="params">(name, ctx, argv)</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;
        <span class="keyword">if</span> (!ctx) <span class="keyword">return</span>;
        <span class="keyword">if</span> (!Array.isArray(ctx.args)) <span class="keyword">return</span>;
        ctx.args.forEach(<span class="function"><span class="keyword">function</span><span class="params">(x)</span> {</span>
            <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"string"</span>) x = { name: x };
            <span class="keyword">if</span> (!x.name) <span class="keyword">return</span>;</pre></div>
        
      
        
        <p>Core sets global parameters, all others by module</p>

        
          <div class='highlight'><pre>            <span class="keyword">var</span> cname = (name == <span class="string">"core"</span> ? <span class="string">""</span> : <span class="string">"-"</span> + name) + <span class="string">'-'</span> + x.name;
            <span class="keyword">if</span> (argv.indexOf(cname) == -<span class="number">1</span>) <span class="keyword">return</span>;
            <span class="keyword">var</span> key = self.toCamel(x.name);
            <span class="keyword">var</span> val = self.getArg(cname, <span class="literal">null</span>, argv);
            <span class="keyword">if</span> (val == <span class="literal">null</span> &amp;&amp; x.type != <span class="string">"bool"</span> &amp;&amp; x.type != <span class="string">"callback"</span>) <span class="keyword">return</span>;</pre></div>
        
      
        
        <p>Ignore the value if it is a parameter</p>

        
          <div class='highlight'><pre>            <span class="keyword">if</span> (val &amp;&amp; val[<span class="number">0</span>] == <span class="string">'-'</span>) val = <span class="string">""</span>; 
            logger.dev(<span class="string">"processArgs:"</span>, name, <span class="string">":"</span>, key, <span class="string">"="</span>, val);
            <span class="keyword">switch</span> (x.type || <span class="string">""</span>) {
            <span class="keyword">case</span> <span class="string">"bool"</span>:
                ctx[key] = !val ? <span class="literal">true</span> : self.toBool(val);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">"number"</span>:
                ctx[key] = self.toNumber(val, x.decimals, x.value, x.min, x.max);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">"list"</span>:
                ctx[key] = val.split(x.separator || <span class="string">","</span>).map(<span class="function"><span class="keyword">function</span><span class="params">(y)</span> {</span> <span class="keyword">return</span> y.trim() });
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">"regexp"</span>:
                ctx[key] = <span class="keyword">new</span> RegExp(val);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">"json"</span>:
                ctx[key] = JSON.parse(val);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">"path"</span>:
                ctx[key] = path.resolve(val);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">"push"</span>:
                <span class="keyword">if</span> (!Array.isArray(ctx[key])) ctx[key] = [];
                ctx[key].push(val);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">"callback"</span>:
                <span class="keyword">if</span> (<span class="keyword">typeof</span> x.value == <span class="string">"string"</span>) {
                    ctx[x.value](val);
                } <span class="keyword">else</span>
                <span class="keyword">if</span> (<span class="keyword">typeof</span> x.value == <span class="string">"function"</span>) {
                    x.value.call(ctx, val);
                }
                <span class="keyword">break</span>;
            <span class="keyword">default</span>:
                ctx[key] = val;
            }
        });
    },</pre></div>
        
      
        
        <p>Parse local config file</p>

        
          <div class='highlight'><pre>    loadConfig: <span class="function"><span class="keyword">function</span><span class="params">(callback)</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;

        fs.readFile(path.join(self.path.etc, <span class="string">"config"</span>), <span class="function"><span class="keyword">function</span><span class="params">(err, data)</span> {</span>
            <span class="keyword">if</span> (!err &amp;&amp; data) {
                <span class="keyword">var</span> argv = [], lines = data.toString().split(<span class="string">"\n"</span>);
                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lines.length; i++) {
                    <span class="keyword">var</span> line = lines[i].split(<span class="string">"="</span>);
                    <span class="keyword">if</span> (line[<span class="number">0</span>]) argv.push(<span class="string">'-'</span> + line[<span class="number">0</span>]);
                    <span class="keyword">if</span> (line[<span class="number">1</span>]) argv.push(line.slice(<span class="number">1</span>).join(<span class="string">'='</span>));
                }
                self.parseArgs(argv);
            }
            <span class="keyword">if</span> (callback) callback();
        });
    },</pre></div>
        
      
        
        <p>Setup 2-way IPC channel between master and worker.
Cache management signaling, all servers maintain local cache per process of account, any server in the cluster
that modifies an account record sends &#39;del&#39; command to clear local caches so the actual record will be re-read from 
the database, all servers share the same database and update it directly. The eviction is done in 2 phases, first local process cache
is cleared and then it sends a broadcast to all servers in the cluster using nanomsg socket, other servers all subscribed to that
socket and listen for messages.</p>

        
          <div class='highlight'><pre>    ipcInitServer: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;</pre></div>
        
      
        
        <p>Attach our message handler to all workers, process requests from workers</p>

        
          <div class='highlight'><pre>        backend.lruInit(self.lruMax);</pre></div>
        
      
        
        <p>Run LRU cache server, receive cache refreshes from the socket, clears/puts cache entry and broadcasts 
it to other connected servers via the same BUS socket</p>

        
          <div class='highlight'><pre>        <span class="keyword">if</span> (self.lruServer) {
            <span class="keyword">var</span> sock = backend.nnCreate(backend.AF_SP_RAW, backend.NN_BUS);
            backend.nnBind(sock, self.lruServer);
            backend.lruServer(<span class="number">0</span>, sock, sock);
        }</pre></div>
        
      
        
        <p>Send cache requests to the LRU host to be broadcasted to all other servers</p>

        
          <div class='highlight'><pre>        <span class="keyword">if</span> (self.lruHost) {
            self.lruSocket = backend.nnCreate(backend.AF_SP, backend.NN_BUS);
            backend.nnConnect(self.lruSocket, self.lruHost);
        }
        
        cluster.on(<span class="string">'fork'</span>, <span class="function"><span class="keyword">function</span><span class="params">(worker)</span> {</span></pre></div>
        
      
        
        <p>Handle cache request from a worker, send back cached value if exists, this method is called inside worker context</p>

        
          <div class='highlight'><pre>            worker.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(msg)</span> {</span>
                <span class="keyword">if</span> (!msg) <span class="keyword">return</span> <span class="literal">false</span>;
                logger.debug(<span class="string">'LRU:'</span>, msg);
                <span class="keyword">switch</span> (msg.cmd) {
                <span class="keyword">case</span> <span class="string">'keys'</span>:
                    msg.value = backend.lruKeys();
                    worker.send(msg);
                    <span class="keyword">break</span>;
                    
                <span class="keyword">case</span> <span class="string">'get'</span>:
                    <span class="keyword">if</span> (msg.key) msg.value = backend.lruGet(msg.key);
                    worker.send(msg);
                    <span class="keyword">break</span>;

                <span class="keyword">case</span> <span class="string">'put'</span>:
                    <span class="keyword">if</span> (msg.key &amp;&amp; msg.value) backend.lruSet(msg.key, msg.value);
                    <span class="keyword">if</span> (msg.reply) worker.send({});
                    <span class="keyword">if</span> (self.lruSocket) backend.nnSend(self.lruSocket, msg.key + <span class="string">"\1"</span> + msg.value);
                    <span class="keyword">break</span>;

                <span class="keyword">case</span> <span class="string">'del'</span>:
                    <span class="keyword">if</span> (msg.key) backend.lruDel(msg.key);
                    <span class="keyword">if</span> (msg.reply) worker.send({});
                    <span class="keyword">if</span> (self.lruSocket) backend.nnSend(self.lruSocket, msg.key);
                    <span class="keyword">break</span>;
                    
                <span class="keyword">case</span> <span class="string">'clear'</span>:
                    backend.lruClear();
                    <span class="keyword">if</span> (msg.reply) worker.send({});
                    <span class="keyword">break</span>;
                }
            });
        });
    },
    
    ipcInitClient: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;

        <span class="keyword">switch</span> (<span class="keyword">this</span>.cacheType || <span class="string">""</span>) {
        <span class="keyword">case</span> <span class="string">"memcache"</span>:
            self.memcacheClient = <span class="keyword">new</span> memcached(self.memcacheHost, self.memcacheOptions || {});
            self.ipcPutCache = <span class="function"><span class="keyword">function</span><span class="params">(k, v)</span> {</span> self.memcacheClient.set(k, v, <span class="number">0</span>); }
            self.ipcDelCache = <span class="function"><span class="keyword">function</span><span class="params">(k)</span> {</span> self.memcacheClient.del(k); }
            self.ipcGetCache = <span class="function"><span class="keyword">function</span><span class="params">(k, cb)</span> {</span> self.memcacheClient.get(k, <span class="function"><span class="keyword">function</span><span class="params">(e,v)</span> {</span> cb(v) }) }
            <span class="keyword">break</span>;
            
        <span class="keyword">case</span> <span class="string">"redis"</span>:
            self.redisClient = redis.createClient(<span class="literal">null</span>, self.redisHost, self.redisOptions || {});
            self.ipcPutCache = <span class="function"><span class="keyword">function</span><span class="params">(k, v)</span> {</span> self.redisClient.set(k, v, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>}); }
            self.ipcDelCache = <span class="function"><span class="keyword">function</span><span class="params">(k)</span> {</span> self.redisClient.del(k, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>}); }
            self.ipcGetCache = <span class="function"><span class="keyword">function</span><span class="params">(k, cb)</span> {</span> self.redisClient.get(k, <span class="function"><span class="keyword">function</span><span class="params">(e,v)</span> {</span> cb(v) }) }
            <span class="keyword">break</span>;
        }</pre></div>
        
      
        
        <p>Event handler for the worker to process response and fire callback</p>

        
          <div class='highlight'><pre>        process.on(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span><span class="params">(msg)</span> {</span>
            <span class="keyword">if</span> (!msg.id) <span class="keyword">return</span>;
            <span class="keyword">if</span> (self.ipcs[msg.id]) setImmediate(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> 
                self.ipcs[msg.id].callback(msg); 
                <span class="keyword">delete</span> self.ipcs[msg.id];
            });
                
            <span class="keyword">switch</span> (msg.cmd) {
            <span class="keyword">case</span> <span class="string">"heapsnapshot"</span>:
                backend.heapSnapshot(<span class="string">"tmp/"</span> + process.pid + <span class="string">".heapsnapshot"</span>);
                <span class="keyword">break</span>;
            }
        });
    },</pre></div>
        
      
        
        <p>Send cache command to the master process via IPC messages, callback is used for commands that return value back</p>

        
          <div class='highlight'><pre>    ipcSend: <span class="function"><span class="keyword">function</span><span class="params">(cmd, key, value, callback)</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;
        <span class="keyword">if</span> (<span class="keyword">typeof</span> value == <span class="string">"function"</span>) callback = value, value = <span class="string">''</span>;
        <span class="keyword">var</span> msg = { cmd: cmd, key: key, value: value };
        <span class="keyword">if</span> (<span class="keyword">typeof</span> callback == <span class="string">"function"</span>) {
            msg.reply = <span class="literal">true</span>;
            msg.id = self.ipcId++;
            self.ipcs[msg.id] = { timeout: setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> <span class="keyword">delete</span> self.ipcs[msg.id]; callback(); }, self.ipcTimeout),
                                  callback: <span class="function"><span class="keyword">function</span><span class="params">(m)</span> {</span> clearTimeout(self.ipcs[msg.id].timeout); callback(m.value); } };
        }
        process.send(msg);
    },

    ipcGetCache: <span class="function"><span class="keyword">function</span><span class="params">(key, callback)</span> {</span> 
        <span class="keyword">if</span> (<span class="keyword">this</span>.noCache) <span class="keyword">return</span> callback ? callback() : <span class="literal">null</span>;
        <span class="keyword">this</span>.ipcSend(<span class="string">"get"</span>, key, callback); 
    },
    
    ipcDelCache: <span class="function"><span class="keyword">function</span><span class="params">(key)</span> {</span> 
        <span class="keyword">if</span> (<span class="keyword">this</span>.noCache) <span class="keyword">return</span>;
        <span class="keyword">this</span>.ipcSend(<span class="string">"del"</span>, key); 
    },
    
    ipcPutCache: <span class="function"><span class="keyword">function</span><span class="params">(key, val)</span> {</span> 
        <span class="keyword">if</span> (<span class="keyword">this</span>.noCache) <span class="keyword">return</span>;
        <span class="keyword">this</span>.ipcSend(<span class="string">"put"</span>, key, val); 
    },</pre></div>
        
      
        
        <p>Encode with additional symbols</p>

        
          <div class='highlight'><pre>    encodeURIComponent: <span class="function"><span class="keyword">function</span><span class="params">(str)</span> {</span>
        <span class="keyword">return</span> encodeURIComponent(str || <span class="string">""</span>).replace(<span class="string">"!"</span>,<span class="string">"%21"</span>,<span class="string">"g"</span>).replace(<span class="string">"*"</span>,<span class="string">"%2A"</span>,<span class="string">"g"</span>).replace(<span class="string">"'"</span>,<span class="string">"%27"</span>,<span class="string">"g"</span>).replace(<span class="string">"("</span>,<span class="string">"%28"</span>,<span class="string">"g"</span>).replace(<span class="string">")"</span>,<span class="string">"%29"</span>,<span class="string">"g"</span>);
    },</pre></div>
        
      
        
        <p>Convert text into captalized words</p>

        
          <div class='highlight'><pre>    toTitle: <span class="function"><span class="keyword">function</span><span class="params">(name)</span> {</span>
        <span class="keyword">return</span> (name || <span class="string">""</span>).replace(<span class="regexp">/_/g</span>, <span class="string">" "</span>).split(<span class="regexp">/[ ]+/</span>).reduce(<span class="function"><span class="keyword">function</span><span class="params">(x,y)</span> {</span> <span class="keyword">return</span> x + y[<span class="number">0</span>].toUpperCase() + y.substr(<span class="number">1</span>) + <span class="string">" "</span>; }, <span class="string">""</span>).trim();
    },</pre></div>
        
      
        
        <p>Convert into camelized form</p>

        
          <div class='highlight'><pre>    toCamel: <span class="function"><span class="keyword">function</span><span class="params">(name)</span> {</span>
        <span class="keyword">return</span> (name || <span class="string">""</span>).replace(<span class="regexp">/(?:[-_])(\w)/g</span>, <span class="function"><span class="keyword">function</span> <span class="params">(_, c)</span> {</span> <span class="keyword">return</span> c ? c.toUpperCase () : <span class="string">''</span>; })
    },</pre></div>
        
      
        
        <p>Safe version, use 0 instead of NaN, handle booleans, if decimals specified, returns float</p>

        
          <div class='highlight'><pre>    toNumber: <span class="function"><span class="keyword">function</span><span class="params">(str, decimals, dflt, min, max)</span> {</span>
        str = String(str);</pre></div>
        
      
        
        <p>Autodetect floating number</p>

        
          <div class='highlight'><pre>        <span class="keyword">if</span> (<span class="keyword">typeof</span> decimals == <span class="string">"undefined"</span> || decimals == <span class="literal">null</span>) decimals = <span class="regexp">/^[0-9]+\.[0-9]+$/</span>.test(str);
        <span class="keyword">if</span> (<span class="keyword">typeof</span> dflt == <span class="string">"undefined"</span>) dflt = <span class="number">0</span>;
        <span class="keyword">var</span> n = str[<span class="number">0</span>] == <span class="string">'t'</span> ? <span class="number">1</span> : str[<span class="number">0</span>] == <span class="string">'f'</span> ? <span class="number">0</span> : (decimals ? parseFloat(str,<span class="number">10</span>) : parseInt(str,<span class="number">10</span>));
        n = isNaN(n) ? dflt : n;
        <span class="keyword">if</span> (<span class="keyword">typeof</span> min != <span class="string">"undefined"</span> &amp;&amp; n &lt; min) n = min;
        <span class="keyword">if</span> (<span class="keyword">typeof</span> max != <span class="string">"undefined"</span> &amp;&amp; n &gt; max) n = max;
        <span class="keyword">return</span> n
    },</pre></div>
        
      
        
        <p>Return true if value represents true condition</p>

        
          <div class='highlight'><pre>    toBool: <span class="function"><span class="keyword">function</span><span class="params">(val)</span> {</span>
        <span class="keyword">return</span> !val || val == <span class="string">"false"</span> || val == <span class="string">"FALSE"</span> || val == <span class="string">"f"</span> || val == <span class="string">"F"</span> || val == <span class="string">"0"</span> ? <span class="literal">false</span> : <span class="literal">true</span>;
    },</pre></div>
        
      
        
        <p>Return Date object for given text or numeric date represantation, for invalid date returns 1969</p>

        
          <div class='highlight'><pre>    toDate: <span class="function"><span class="keyword">function</span><span class="params">(val)</span> {</span>
        <span class="keyword">var</span> d = <span class="literal">null</span>;</pre></div>
        
      
        
        <p>Assume it is seconds which we use for most mtime columns, convert to milliseconds</p>

        
          <div class='highlight'><pre>        <span class="keyword">if</span> (<span class="keyword">typeof</span> val == <span class="string">"number"</span> &amp;&amp; val &lt; <span class="number">2147483647</span>) val *= <span class="number">1000</span>;
        <span class="keyword">try</span> { d = <span class="keyword">new</span> Date(val); } <span class="keyword">catch</span>(e) {}
        <span class="keyword">return</span> d || <span class="keyword">new</span> Date(<span class="number">0</span>);
    },</pre></div>
        
      
        
        <p>Convert value to the proper type</p>

        
          <div class='highlight'><pre>    toValue: <span class="function"><span class="keyword">function</span><span class="params">(val, type)</span> {</span>
        <span class="keyword">switch</span> ((type || <span class="keyword">this</span>.typeName(val))) {
        <span class="keyword">case</span> <span class="string">'array'</span>:
            <span class="keyword">return</span> Array.isArray(val) ? val : String(val).split(<span class="regexp">/[,\|]/</span>);
            
        <span class="keyword">case</span> <span class="string">"expr"</span>:
        <span class="keyword">case</span> <span class="string">"buffer"</span>:
            <span class="keyword">return</span> val;

        <span class="keyword">case</span> <span class="string">"real"</span>:
        <span class="keyword">case</span> <span class="string">"float"</span>:
        <span class="keyword">case</span> <span class="string">"double"</span>:
            <span class="keyword">return</span> core.toNumber(val, <span class="literal">true</span>);

        <span class="keyword">case</span> <span class="string">"int"</span>:
        <span class="keyword">case</span> <span class="string">"integer"</span>:
        <span class="keyword">case</span> <span class="string">"number"</span>:
            <span class="keyword">return</span> core.toNumber(val);

        <span class="keyword">case</span> <span class="string">"bool"</span>:
        <span class="keyword">case</span> <span class="string">"boolean"</span>:
            <span class="keyword">return</span> core.toBool(val);

        <span class="keyword">case</span> <span class="string">"date"</span>:
        <span class="keyword">case</span> <span class="string">"time"</span>:
            <span class="keyword">return</span> <span class="keyword">this</span>.toDate(val);

        <span class="keyword">case</span> <span class="string">"mtime"</span>:
            <span class="keyword">return</span> <span class="regexp">/^[0-9\.]+$/</span>.test(value) ? <span class="keyword">this</span>.toNumber(val) : (<span class="keyword">new</span> Date(val));

        <span class="keyword">default</span>:
            <span class="keyword">return</span> val;
        }
    },</pre></div>
        
      
        
        <p>Evaluate expr, compare 2 values with optional type and opertion</p>

        
          <div class='highlight'><pre>    isTrue: <span class="function"><span class="keyword">function</span><span class="params">(val1, val2, op, type)</span> {</span>
        <span class="keyword">switch</span> ((op ||<span class="string">""</span>).toLowerCase()) {
        <span class="keyword">case</span> <span class="string">'null'</span>:
            <span class="keyword">if</span> (v) <span class="keyword">return</span> <span class="literal">false</span>;
            <span class="keyword">break</span>;
            
        <span class="keyword">case</span> <span class="string">'not null'</span>:
            <span class="keyword">if</span> (!v) <span class="keyword">return</span> <span class="literal">false</span>;
            <span class="keyword">break</span>;
            
        <span class="keyword">case</span> <span class="string">"&gt;"</span>:
        <span class="keyword">case</span> <span class="string">"gt"</span>:
            <span class="keyword">if</span> (<span class="keyword">this</span>.toValue(val1, type) &lt;= <span class="keyword">this</span>.toValue(val2, type)) <span class="keyword">return</span> <span class="literal">false</span>;
            <span class="keyword">break</span>;
            
        <span class="keyword">case</span> <span class="string">"&lt;"</span>:
        <span class="keyword">case</span> <span class="string">"lt"</span>:
            <span class="keyword">if</span> (<span class="keyword">this</span>.toValue(val1, type) &gt;= <span class="keyword">this</span>.toValue(val2, type)) <span class="keyword">return</span> <span class="literal">false</span>;
            <span class="keyword">break</span>;

        <span class="keyword">case</span> <span class="string">"&gt;="</span>:
        <span class="keyword">case</span> <span class="string">"ge"</span>:
            <span class="keyword">if</span> (<span class="keyword">this</span>.toValue(val1, type) &lt; <span class="keyword">this</span>.toValue(val2, type)) <span class="keyword">return</span> <span class="literal">false</span>;
            <span class="keyword">break</span>;
            
        <span class="keyword">case</span> <span class="string">"&lt;="</span>:
        <span class="keyword">case</span> <span class="string">"le"</span>:
            <span class="keyword">if</span> (<span class="keyword">this</span>.toValue(val1, type) &gt; <span class="keyword">this</span>.toValue(val2, type)) <span class="keyword">return</span> <span class="literal">false</span>;
            <span class="keyword">break</span>;
            
        <span class="keyword">case</span> <span class="string">"between"</span>:
        <span class="keyword">case</span> <span class="string">"not between"</span>:</pre></div>
        
      
        
        <p>If we cannot parse out 2 values, treat this as exact operator</p>

        
          <div class='highlight'><pre>            <span class="keyword">var</span> list = [];
            <span class="keyword">switch</span> (core.typeName(val2)) {
            <span class="keyword">case</span> <span class="string">"array"</span>:
                list = val2;
                <span class="keyword">break</span>;

            <span class="keyword">case</span> <span class="string">"string"</span>:</pre></div>
        
      
        
        <p>For number array allow to be separated by comma as well, either one but not to be mixed</p>

        
          <div class='highlight'><pre>                <span class="keyword">if</span> ((type == <span class="string">"number"</span> || type == <span class="string">"int"</span>) &amp;&amp; val2.indexOf(<span class="string">','</span>) &gt; -<span class="number">1</span>) {
                    list = val2.split(<span class="string">','</span>);
                    <span class="keyword">break</span>;
                } <span class="keyword">else</span>
                <span class="keyword">if</span> (value.indexOf(<span class="string">'|'</span>) &gt; -<span class="number">1</span>) {
                    list = val2.split(<span class="string">'|'</span>);
                    <span class="keyword">break</span>;
                }
            }
            <span class="keyword">if</span> (list.length &gt; <span class="number">1</span>) {
                <span class="keyword">if</span> (<span class="keyword">this</span>.toValue(val1, type) &lt; <span class="keyword">this</span>.toValue(list[<span class="number">0</span>], type) || <span class="keyword">this</span>.toValue(val1, type) &gt; <span class="keyword">this</span>.toValue(list[<span class="number">1</span>], type)) <span class="keyword">return</span> <span class="literal">false</span>;
            } <span class="keyword">else</span> {
                <span class="keyword">if</span> (<span class="keyword">this</span>.toValue(val1, type) != <span class="keyword">this</span>.toValue(val2, type)) <span class="keyword">return</span> <span class="literal">false</span>;
            }
            <span class="keyword">break</span>;
            
        <span class="keyword">case</span> <span class="string">'~* any'</span>:
        <span class="keyword">case</span> <span class="string">'!~* any'</span>:
            <span class="keyword">break</span>;

        <span class="keyword">case</span> <span class="string">'like%'</span>:
        <span class="keyword">case</span> <span class="string">"ilike%"</span>:
        <span class="keyword">case</span> <span class="string">"not like%"</span>:
        <span class="keyword">case</span> <span class="string">"not ilike%"</span>:
            <span class="keyword">break</span>;
            
        <span class="keyword">case</span> <span class="string">"!~"</span>:
        <span class="keyword">case</span> <span class="string">"!~*"</span>:
        <span class="keyword">case</span> <span class="string">"iregexp"</span>:
        <span class="keyword">case</span> <span class="string">"not iregexp"</span>:
            <span class="keyword">break</span>;
            
        <span class="keyword">case</span> <span class="string">"in"</span>:
        <span class="keyword">case</span> <span class="string">"not in"</span>:
            <span class="keyword">break</span>;
            
        <span class="keyword">case</span> <span class="string">"~"</span>:
        <span class="keyword">case</span> <span class="string">"~*"</span>:
        <span class="keyword">case</span> <span class="string">"regexp"</span>:
        <span class="keyword">case</span> <span class="string">"not regexp"</span>:
            <span class="keyword">break</span>;
            
        <span class="keyword">case</span> <span class="string">"!="</span>:
        <span class="keyword">case</span> <span class="string">"&lt;&gt;"</span>:
            <span class="keyword">if</span> (<span class="keyword">this</span>.toValue(val1, type) == <span class="keyword">this</span>.toValue(val2, type)) <span class="keyword">return</span> <span class="literal">false</span>;
            <span class="keyword">break</span>;
            
        <span class="keyword">default</span>:
            <span class="keyword">if</span> (<span class="keyword">this</span>.toValue(val1, type) != <span class="keyword">this</span>.toValue(val2, type)) <span class="keyword">return</span> <span class="literal">false</span>;
        }
        <span class="keyword">return</span> <span class="literal">true</span>;
    },</pre></div>
        
      
        
        <p>Downloads file using HTTP and pass it to the callback if provided</p>
<ul>
<li>uri can be full URL or an object with parts of the url, same format as in url.format</li>
<li>params can contain the following options:<ul>
<li>method - GET, POST</li>
<li>headers - object with headers to pass to HTTP request, properties must be all lower case</li>
<li>cookies - a list with cookies or a boolean to load cookies from the db</li>
<li>file - file name where to save response, in case of error response the error body will be saved as well</li>
<li>postdata - data to be sent with the request in the body</li>
<li>postfile - file to be uploaded in the POST body, not as multipart</li>
<li>query - aditional query parameters to be added to the url as an object or as encoded string</li>
<li>sign - sign request with provided email/secret properties</li>
</ul>
</li>
<li>callback will be called with the arguments:
  first argument is error object if any
  second is params object itself with updted fields
  third is HTTP response object
On end, the object params will contains the following updated properties:<ul>
<li>data if file was not specified, data eill contain collected response body as string</li>
<li>status - HTTP response status code</li>
<li>mtime - Date object with the last modified time of the requested file</li>
<li>size - size of the response body or file
Note: SIDE EFFECT: params object is modified in place so many options will be changed/removed or added</li>
</ul>
</li>
</ul>

        
          <div class='highlight'><pre>    httpGet: <span class="function"><span class="keyword">function</span><span class="params">(uri, params, callback)</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;
        <span class="keyword">if</span> (<span class="keyword">typeof</span> params == <span class="string">"function"</span>) callback = params, params = <span class="literal">null</span>;
        <span class="keyword">if</span> (!params) params = {};</pre></div>
        
      
        
        <p>Aditional query parameters as an object</p>

        
          <div class='highlight'><pre>        <span class="keyword">var</span> qtype = <span class="keyword">this</span>.typeName(params.query);
        <span class="keyword">switch</span> (<span class="keyword">this</span>.typeName(uri)) {
        <span class="keyword">case</span> <span class="string">"object"</span>:
            uri = url.format(uri);
            <span class="keyword">break</span>;
            
        <span class="keyword">case</span> <span class="string">"string"</span>:
            <span class="keyword">var</span> q = url.format({ query: qtype == <span class="string">"object"</span> ? params.query: <span class="literal">null</span>, search: qtype == <span class="string">"string"</span> ? params.query: <span class="literal">null</span> });
            uri += uri.indexOf(<span class="string">"?"</span>) == -<span class="number">1</span> ? q : q.substr(<span class="number">1</span>);
            <span class="keyword">break</span>;
            
        <span class="keyword">default</span>:
            <span class="keyword">return</span> callback ? callback(<span class="keyword">new</span> Error(<span class="string">"invalid url: "</span> + uri)) : <span class="literal">null</span>;
        }
        
        <span class="keyword">var</span> options = url.parse(uri);
        options.method = params.method || <span class="string">'GET'</span>;
        options.headers = params.headers || {};
        options.agent = params.agent || <span class="literal">null</span>;
        options.rejectUnauthorized = <span class="literal">false</span>;</pre></div>
        
      
        
        <p>Make sure required headers are set</p>

        
          <div class='highlight'><pre>        <span class="keyword">if</span> (!options.headers[<span class="string">'user-agent'</span>]) {
            options.headers[<span class="string">'user-agent'</span>] = <span class="keyword">this</span>.userAgent[<span class="keyword">this</span>.randomInt(<span class="number">0</span>, <span class="keyword">this</span>.userAgent.length-<span class="number">1</span>)];
        }
        <span class="keyword">if</span> (options.method == <span class="string">"POST"</span> &amp;&amp; !options.headers[<span class="string">"content-type"</span>]) {
            options.headers[<span class="string">"content-type"</span>] = <span class="string">"application/x-www-form-urlencoded"</span>;
        }</pre></div>
        
      
        
        <p>Load matched cookies and restart with the cookie list in the params</p>

        
          <div class='highlight'><pre>        <span class="keyword">if</span> (params.cookies) {
            <span class="keyword">if</span> (<span class="keyword">typeof</span> params.cookies == <span class="string">"boolean"</span> &amp;&amp; options.hostname) {
                <span class="keyword">this</span>.cookieGet(options.hostname, <span class="function"><span class="keyword">function</span><span class="params">(cookies)</span> {</span>
                    params.cookies = cookies;
                    self.httpGet(uri, params, callback);
                });
                <span class="keyword">return</span>;
            }</pre></div>
        
      
        
        <p>Cookie list already provided, just use it</p>

        
          <div class='highlight'><pre>            <span class="keyword">if</span> (Array.isArray(params.cookies)) {
                options.headers[<span class="string">"cookie"</span>] = params.cookies.map(<span class="function"><span class="keyword">function</span><span class="params">(c)</span> {</span> <span class="keyword">return</span> c.name+<span class="string">"="</span>+c.value; }).join(<span class="string">"; "</span>);
                logger.debug(<span class="string">'httpGet:'</span>, uri, options.headers);
            }
        }
        <span class="keyword">if</span> (!options.headers[<span class="string">'accept'</span>]) {
            options.headers[<span class="string">'accept'</span>] = <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'</span>;
        }
        options.headers[<span class="string">'accept-language'</span>] = <span class="string">'en-US,en;q=0.5'</span>;</pre></div>
        
      
        
        <p>Data to be sent over in the body</p>

        
          <div class='highlight'><pre>        <span class="keyword">if</span> (params.postdata) {
            <span class="keyword">if</span> (options.method == <span class="string">"GET"</span>) options.method = <span class="string">"POST"</span>;
            <span class="keyword">switch</span> (<span class="keyword">this</span>.typeName(params.postdata)) {
            <span class="keyword">case</span> <span class="string">"string"</span>:
            <span class="keyword">case</span> <span class="string">"buffer"</span>:
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">"object"</span>:
                params.postdata = JSON.stringify(params.postdata);
                options.headers[<span class="string">'content-type'</span>] = <span class="string">"application/json"</span>;
                <span class="keyword">break</span>;
            <span class="keyword">default</span>:
                params.postdata = String(params.postdata);
            }
            options.headers[<span class="string">'content-length'</span>] = params.postdata.length; 
        } <span class="keyword">else</span>
        <span class="keyword">if</span> (params.postfile) {
            <span class="keyword">if</span> (options.method == <span class="string">"GET"</span>) options.method = <span class="string">"POST"</span>;
            options.headers[<span class="string">'transfer-encoding'</span>] = <span class="string">'chunked'</span>;
            params.poststream = fs.createReadableStream(params.postfile);
            params.poststream.on(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> {</span> logger.error(<span class="string">'httpGet: stream:'</span>, params.postfile, err) });
        }</pre></div>
        
      
        
        <p>Make sure our data is not corrupted</p>

        
          <div class='highlight'><pre>        <span class="keyword">if</span> (params.checksum) options.checksum = params.postdata ? <span class="keyword">this</span>.hash(params.postdata) : <span class="literal">null</span>;</pre></div>
        
      
        
        <p>Sign request using internal backend credentials</p>

        
          <div class='highlight'><pre>        <span class="keyword">if</span> (params.sign) {
            <span class="keyword">var</span> headers = <span class="keyword">this</span>.signRequest(params.email, params.secret, options.method, options.hostname, options.path, <span class="number">0</span>, options.checksum);
            <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> headers) options.headers[p] = headers[p];
        }</pre></div>
        
      
        
        <p>Runtime properties</p>

        
          <div class='highlight'><pre>        <span class="keyword">if</span> (!params.retries) params.retries = <span class="number">0</span>;
        <span class="keyword">if</span> (!params.redirects) params.redirects = <span class="number">0</span>;
        <span class="keyword">if</span> (!params.httpTimeout) params.httpTimeout = <span class="number">300000</span>;
        <span class="keyword">if</span> (!params.ignoreredirect) params.ignoreredirect = {};
        params.size = <span class="number">0</span>, params.err = <span class="literal">null</span>, params.fd = <span class="number">0</span>, params.status = <span class="number">0</span>, params.data = <span class="string">''</span>, params.poststream = <span class="literal">null</span>;
        params.href = options.href, params.pathname = options.pathname, params.hostname = options.hostname;
        <span class="keyword">var</span> req = <span class="literal">null</span>;
        <span class="keyword">var</span> mod = uri.indexOf(<span class="string">"https://"</span>) == <span class="number">0</span> ? https : http;

        req = mod.request(options, <span class="function"><span class="keyword">function</span><span class="params">(res)</span> {</span>
          logger.dev(<span class="string">"httpGet: started"</span>, options.method, <span class="string">'headers:'</span>, options.headers, params)
          
          res.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span><span class="params">(chunk)</span> {</span>
              logger.dev(<span class="string">"httpGet: data"</span>, <span class="string">'size:'</span>, chunk.length, <span class="string">'/'</span>, params.size, <span class="string">"status:"</span>, res.statusCode, <span class="string">'file:'</span>, params.file || <span class="string">''</span>);

              <span class="keyword">if</span> (params.stream) {
                  <span class="keyword">try</span> {
                      params.stream.write(chunk);
                  } <span class="keyword">catch</span>(e) {
                      <span class="keyword">if</span> (!params.quiet) logger.error(<span class="string">'httpGet:'</span>, <span class="string">"stream:"</span>, e);
                      params.err = e;
                      req.abort();
                  }
              } <span class="keyword">else</span>
              <span class="keyword">if</span> (params.file) {
                  <span class="keyword">try</span> {
                      <span class="keyword">if</span> (!params.fd &amp;&amp; res.statusCode &gt;= <span class="number">200</span> &amp;&amp; res.statusCode &lt; <span class="number">300</span>) {
                          params.fd = fs.openSync(params.file, <span class="string">'w'</span>);
                      }
                      <span class="keyword">if</span> (params.fd) {
                          fs.writeSync(params.fd, chunk, <span class="number">0</span>, chunk.length, <span class="literal">null</span>);
                      }
                  } <span class="keyword">catch</span>(e) {
                      <span class="keyword">if</span> (!params.quiet) logger.error(<span class="string">'httpGet:'</span>, <span class="string">"file:"</span>, params.file, e);
                      params.err = e;
                      req.abort();
                  }
              } <span class="keyword">else</span> {
                  params.data += chunk.toString();
              }
              params.size += chunk.length
          });

          res.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span></pre></div>
        
      
        
        <p>Array means we wanted to use cookies just did not have existing before the request, now we can save the ones we received</p>

        
          <div class='highlight'><pre>              <span class="keyword">if</span> (Array.isArray(params.cookies)) {
                  self.cookieSave(params.cookies, res.headers[<span class="string">"set-cookie"</span>], params.hostname);
              }
              params.headers = res.headers;
              params.status = res.statusCode;
              params.type = (res.headers[<span class="string">'content-type'</span>] || <span class="string">''</span>).split(<span class="string">';'</span>)[<span class="number">0</span>];
              params.mtime = res.headers.date ? <span class="keyword">new</span> Date(res.headers.date) : <span class="literal">null</span>;
              <span class="keyword">if</span> (!params.size) params.size = self.toNumber(res.headers[<span class="string">'content-length'</span>] || <span class="number">0</span>);
              <span class="keyword">if</span> (params.fd) <span class="keyword">try</span> { fs.closeSync(params.fd); } <span class="keyword">catch</span>(e) {}
              <span class="keyword">if</span> (params.stream) <span class="keyword">try</span> { params.stream.end(params.onfinish); } <span class="keyword">catch</span>(e) {}
              params.fd = <span class="number">0</span>;

              logger.debug(<span class="string">"httpGet: end"</span>, options.method, <span class="string">"url:"</span>, uri, <span class="string">"size:"</span>, params.size, <span class="string">"status:"</span>, params.status, <span class="string">'type:'</span>, params.type, <span class="string">'location:'</span>, res.headers.location || <span class="string">''</span>);</pre></div>
        
      
        
        <p>Retry the same request</p>

        
          <div class='highlight'><pre>              <span class="keyword">if</span> (params.retries &amp;&amp; (res.statusCode &lt; <span class="number">200</span> || res.statusCode &gt;= <span class="number">400</span>)) {
                  params.retries--;
                  setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> self.httpGet(uri, params, callback); }, params.retryTimeout || <span class="number">500</span>);
                  <span class="keyword">return</span>;
              }</pre></div>
        
      
        
        <p>Redirection</p>

        
          <div class='highlight'><pre>              <span class="keyword">if</span> (res.statusCode &gt;= <span class="number">301</span> &amp;&amp; res.statusCode &lt;= <span class="number">307</span> &amp;&amp; !params.noredirects) {
                  params.redirects += <span class="number">1</span>;
                  <span class="keyword">if</span> (params.redirects &lt; <span class="number">10</span>) {
                      <span class="keyword">var</span> uri2 = res.headers.location;
                      <span class="keyword">if</span> (uri2.indexOf(<span class="string">"://"</span>) == -<span class="number">1</span>) {
                          uri2 = options.protocol + <span class="string">"//"</span> + options.host + uri2;
                      }
                      logger.dev(<span class="string">'httpGet:'</span>, <span class="string">'redirect'</span>, uri2);</pre></div>
        
      
        
        <p>Ignore redirects we dont want and return data recieved</p>

        
          <div class='highlight'><pre>                      <span class="keyword">if</span> (!params.ignoreredirect[uri2]) {
                          [<span class="string">'method'</span>,<span class="string">'query'</span>,<span class="string">'headers'</span>,<span class="string">'postdata'</span>,<span class="string">'postfile'</span>,<span class="string">'poststream'</span>,<span class="string">'sign'</span>,<span class="string">'checksum'</span>].forEach(<span class="function"><span class="keyword">function</span><span class="params">(x)</span> {</span> <span class="keyword">delete</span> params[x] });
                          <span class="keyword">if</span> (params.cookies) params.cookies = <span class="literal">true</span>;
                          <span class="keyword">return</span> self.httpGet(uri2, params, callback);
                      }
                  }
              }
              logger.debug(<span class="string">"httpGet: done"</span>, options.method, <span class="string">"url:"</span>, uri, <span class="string">"size:"</span>, params.size, <span class="string">"status:"</span>, res.statusCode, <span class="string">'type:'</span>, params.type, <span class="string">'location:'</span>, res.headers.location || <span class="string">''</span>);

              <span class="keyword">if</span> (callback) callback(params.err, params, res);
          });

        }).on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> {</span>
            <span class="keyword">if</span> (!params.quiet) logger.error(<span class="string">"httpGet:"</span>, <span class="string">"onerror:"</span>, uri, <span class="string">'file:'</span>, params.file || <span class="string">""</span>, <span class="string">'retries:'</span>, params.retries, <span class="string">'timeout:'</span>, params.httpTimeout, <span class="string">'size;'</span>, params.size, err);</pre></div>
        
      
        
        <p>Keep trying if asked for it</p>

        
          <div class='highlight'><pre>            <span class="keyword">if</span> (params.retries) {
                params.retries--;
                setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> self.httpGet(uri, params, callback); }, params.retryTimeout || <span class="number">500</span>);
                <span class="keyword">return</span>;
            }
            <span class="keyword">if</span> (callback) callback(err, params, {});
        });
        <span class="keyword">if</span> (params.httpTimeout) {
            req.setTimeout(params.httpTimeout, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                <span class="keyword">if</span> (!params.quiet) logger.error(<span class="string">"httpGet:"</span>, <span class="string">"timeout:"</span>, uri, <span class="string">'file:'</span>, params.file || <span class="string">""</span>, <span class="string">'retries:'</span>, params.retries, <span class="string">'timeout:'</span>, params.httpTimeout);
                req.abort();
            });
        }
        <span class="keyword">if</span> (params.postdata) {
            req.write(params.postdata);
        } <span class="keyword">else</span>
        <span class="keyword">if</span> (params.poststream) {
            params.poststream.pipe(req);
            <span class="keyword">return</span> req;
        }
        req.end();
        <span class="keyword">return</span> req;
    },</pre></div>
        
      
        
        <p>Produce signed URL to be used in embeded cases or with expiration so the url can be passed and be valid for longer time.
Host passed here must be the actual host where the request will be sent</p>

        
          <div class='highlight'><pre>    signUrl: <span class="function"><span class="keyword">function</span><span class="params">(accesskey, secret, host, uri, expires)</span> {</span>
        <span class="keyword">var</span> hdrs = <span class="keyword">this</span>.signRequest(accesskey, secret, <span class="string">"GET"</span>, host, uri, <span class="string">""</span>, expires);
        <span class="keyword">return</span> uri + (uri.indexOf(<span class="string">"?"</span>) == -<span class="number">1</span> ? <span class="string">"?"</span> : <span class="string">""</span>) + <span class="string">"&amp;v-signature="</span> + encodeURIComponent(hdrs[<span class="string">'v-signature'</span>]);
    },</pre></div>
        
      
        
        <p>Sign HTTP request for the API server:
url must include all query parametetrs already encoded and ready to be sent
expires is absolute time in milliseconds when this request will expire, default is 30 seconds from now
checksum is SHA1 digest of the POST content, optional</p>

        
          <div class='highlight'><pre>    signRequest: <span class="function"><span class="keyword">function</span><span class="params">(id, secret, method, host, uri, expires, checksum)</span> {</span>
        <span class="keyword">var</span> now = Date.now();
        <span class="keyword">if</span> (!expires) expires = now + <span class="number">30000</span>;
        <span class="keyword">if</span> (expires &lt; now) expires += now;
        <span class="keyword">var</span> q = String(uri || <span class="string">"/"</span>).split(<span class="string">"?"</span>);
        <span class="keyword">var</span> qpath = q[<span class="number">0</span>];
        <span class="keyword">var</span> query = (q[<span class="number">1</span>] || <span class="string">""</span>).split(<span class="string">"&amp;"</span>).sort().filter(<span class="function"><span class="keyword">function</span><span class="params">(x)</span> {</span> <span class="keyword">return</span> x != <span class="string">""</span>; }).join(<span class="string">"&amp;"</span>);
        <span class="keyword">var</span> str = String(method) + <span class="string">"\n"</span> + String(host) + <span class="string">"\n"</span> + String(qpath) + <span class="string">"\n"</span> + String(query) + <span class="string">"\n"</span> + String(expires) + <span class="string">"\n"</span> + String(checksum || <span class="string">""</span>);
        <span class="keyword">return</span> { <span class="string">'v-signature'</span>: <span class="string">'1;;'</span> + String(id) + <span class="string">';'</span> + <span class="keyword">this</span>.sign(String(secret), str) + <span class="string">';'</span> + expires + <span class="string">';'</span> + String(checksum || <span class="string">""</span>) + <span class="string">';;'</span> };
    },</pre></div>
        
      
        
        <p>Parse incomomg request for signature and return all pieces wrapped in an object, this object
will be used by checkSignature function for verification against an account</p>

        
          <div class='highlight'><pre>    parseSignature: <span class="function"><span class="keyword">function</span><span class="params">(req)</span> {</span>
        <span class="keyword">var</span> rc = { version: <span class="number">1</span>, expires: <span class="number">0</span>, checksum: <span class="string">""</span>, password: <span class="string">""</span> };</pre></div>
        
      
        
        <p>Input parameters, convert to empty string if not present</p>

        
          <div class='highlight'><pre>        rc.url = req.originalUrl || req.url || <span class="string">"/"</span>;
        rc.method = req.method || <span class="string">""</span>;
        rc.host = (req.headers.host || <span class="string">""</span>).split(<span class="string">':'</span>)[<span class="number">0</span>];
        rc.signature = req.query[<span class="string">'v-signature'</span>] || req.headers[<span class="string">'v-signature'</span>] || <span class="string">""</span>;
        <span class="keyword">var</span> d = String(rc.signature).match(<span class="regexp">/([^;]+);([^;]*);([^;]+);([^;]+);([^;]+);([^;]*);([^;]*);/</span>);
        <span class="keyword">if</span> (!d) <span class="keyword">return</span> rc;
        rc.mode = <span class="keyword">this</span>.toNumber(d[<span class="number">1</span>]);
        rc.version = d[<span class="number">2</span>] || <span class="string">""</span>;
        rc.id = d[<span class="number">3</span>];
        rc.signature = d[<span class="number">4</span>];
        rc.expires = <span class="keyword">this</span>.toNumber(d[<span class="number">5</span>]);
        rc.checksum = d[<span class="number">6</span>] || <span class="string">""</span>;
        rc.url = req.url.replace(<span class="regexp">/v-signature=([^&amp; ]+)/g</span>, <span class="string">""</span>);
        <span class="keyword">return</span> rc;
    },</pre></div>
        
      
        
        <p>Verify signature with given account, signature is an object reurned by parseSignature</p>

        
          <div class='highlight'><pre>    checkSignature: <span class="function"><span class="keyword">function</span><span class="params">(sig, account)</span> {</span>
        <span class="keyword">var</span> q = sig.url.split(<span class="string">"?"</span>);
        <span class="keyword">var</span> qpath = q[<span class="number">0</span>];
        <span class="keyword">var</span> query = (q[<span class="number">1</span>] || <span class="string">""</span>).split(<span class="string">"&amp;"</span>).sort().filter(<span class="function"><span class="keyword">function</span><span class="params">(x)</span> {</span> <span class="keyword">return</span> x != <span class="string">""</span>; }).join(<span class="string">"&amp;"</span>);
        sig.str = sig.method + <span class="string">"\n"</span> + sig.host + <span class="string">"\n"</span> + qpath + <span class="string">"\n"</span> + query + <span class="string">"\n"</span> + sig.expires + <span class="string">"\n"</span> + sig.checksum;
        <span class="keyword">switch</span> (sig.mode) {
        <span class="keyword">case</span> <span class="number">1</span>:
            sig.hash = <span class="keyword">this</span>.sign(account.secret, sig.str);
            <span class="keyword">return</span> sig.signature == sig.hash;
            
        <span class="keyword">case</span> <span class="number">2</span>:</pre></div>
        
      
        
        <p>Verify against digest of the account and and secret, this way a client stores not the 
actual secret in local storage but sha1 digest to prevent exposing the real password</p>

        
          <div class='highlight'><pre>            sig.hash = <span class="keyword">this</span>.sign(<span class="keyword">this</span>.sign(account.secret, account.email), sig.str);
            <span class="keyword">return</span> sig.signature == sig.hash;
        }
        <span class="keyword">return</span> <span class="literal">false</span>;
    },</pre></div>
        
      
        
        <p>Make a request to the backend endpoint, save data in the queue in case of error, if data specified,
POST request is made, if data is an object, it is converted into string.
Returns params as in httpGet with .json property assigned with an object from parsed JSON response
Special parameters for options:</p>
<ul>
<li>email - email to use for access credentials insted of global credentials</li>
<li>secret - secret to use for access intead of global credentials</li>
<li>proxy - used as a proxy to backend, handles all errors and returns .status and .json to be passed back to API client</li>
<li>queue - perform queue management, save in queue if cannot send right now, delete from queue if sent</li>
<li>rowid - unique record id to be used in case of queue management</li>
<li>checksum - calculate checksum from the data</li>
</ul>

        
          <div class='highlight'><pre>    sendRequest: <span class="function"><span class="keyword">function</span><span class="params">(uri, options, callback)</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;
        <span class="keyword">if</span> (<span class="keyword">typeof</span> options == <span class="string">"function"</span>) callback = options, options = {};
        <span class="keyword">if</span> (!options) options = {};
        options.sign = <span class="literal">true</span>;</pre></div>
        
      
        
        <p>Nothing to do without credentials</p>

        
          <div class='highlight'><pre>        <span class="keyword">if</span> (!options.email) options.email = self.backendKey;
        <span class="keyword">if</span> (!options.secret) options.secret = self.backendSecret;
        <span class="keyword">if</span> (!options.email || !options.secret) {
            logger.debug(<span class="string">'sendRequest:'</span>, <span class="string">'no backend credentials'</span>, uri, options);
            <span class="keyword">return</span> callback ? callback(<span class="literal">null</span>, { status: <span class="number">200</span>, message: <span class="string">""</span>, json: { status: <span class="number">200</span> } }) : <span class="literal">null</span>;
        }</pre></div>
        
      
        
        <p>Relative urls resolve against global backend host</p>

        
          <div class='highlight'><pre>        <span class="keyword">if</span> (uri.indexOf(<span class="string">"://"</span>) == -<span class="number">1</span>) uri = self.backendHost + uri; 
        
        <span class="keyword">var</span> db = self.context.db;
        self.httpGet(uri, options, <span class="function"><span class="keyword">function</span><span class="params">(err, params, res)</span> {</span></pre></div>
        
      
        
        <p>Queue management, insert on failure or delete on success</p>

        
          <div class='highlight'><pre>            <span class="keyword">if</span> (options.queue) {
                <span class="keyword">if</span> (params.status == <span class="number">200</span>) {
                    <span class="keyword">if</span> (options.id) {
                        db.del(<span class="string">"backend_queue"</span>, { id: options.id });
                    }
                } <span class="keyword">else</span> {
                    <span class="keyword">if</span> (!options.id) options.id = core.hash(uri + (options.postdata || <span class="string">""</span>));
                    options.mtime = self.now();
                    options.counter = (options.counter || <span class="number">0</span>) + <span class="number">1</span>;
                    <span class="keyword">if</span> (options.counter &gt; <span class="number">10</span>) {
                        db.del(<span class="string">"backend_queue"</span>, { id: options.id });
                    } <span class="keyword">else</span> {
                        db.put(<span class="string">"backend_queue"</span>, options);
                    }
                }
            }</pre></div>
        
      
        
        <p>If the contents are encrypted, decrypt before processing content type</p>

        
          <div class='highlight'><pre>            <span class="keyword">if</span> ((options.headers || {})[<span class="string">'content-encoding'</span>] == <span class="string">"encrypted"</span>) {
                params.data = self.decrypt(options.secret, params.data);
            }</pre></div>
        
      
        
        <p>Parse JSON and store in the params, set error if cannot be parsed, the caller will deal with it</p>

        
          <div class='highlight'><pre>            <span class="keyword">if</span> (params.data &amp;&amp; params.type == <span class="string">"application/json"</span>) {
                <span class="keyword">try</span> {
                    params.obj = JSON.parse(params.data);
                } <span class="keyword">catch</span>(e) {
                    err = e;
                }
            }
            <span class="keyword">if</span> (params.status != <span class="number">200</span>) err = <span class="keyword">new</span> Error(<span class="string">"HTTP error: "</span> + params.status);
            <span class="keyword">if</span> (callback) callback(err, params, res);
        });
    },</pre></div>
        
      
        
        <p>Send all pending updates from the queue table</p>

        
          <div class='highlight'><pre>    processQueue: <span class="function"><span class="keyword">function</span><span class="params">(callback)</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;
        <span class="keyword">var</span> db = self.context.db;
        
        db.select(<span class="string">"backend_queue"</span>, {}, { sort: <span class="string">"mtime"</span> } , <span class="function"><span class="keyword">function</span><span class="params">(err, rows)</span> {</span>
            async.forEachSeries(rows, <span class="function"><span class="keyword">function</span><span class="params">(row, next)</span> {</span>
                self.sendRequest(row.url, self.extendObj(row, <span class="string">"queue"</span>, <span class="literal">true</span>), <span class="function"><span class="keyword">function</span><span class="params">(err2)</span> {</span> next(); });
            }, <span class="function"><span class="keyword">function</span><span class="params">(err3)</span> {</span>
                <span class="keyword">if</span> (rows.length) logger.log(<span class="string">'processQueue:'</span>, <span class="string">'sent'</span>, rows.length);
                <span class="keyword">if</span> (callback) callback();
            });
        });
    },</pre></div>
        
      
        
        <p>Return argument value by name</p>

        
          <div class='highlight'><pre>    getArg: <span class="function"><span class="keyword">function</span><span class="params">(name, dflt, argv)</span> {</span>
        argv = argv || <span class="keyword">this</span>.argv;
        <span class="keyword">var</span> idx = argv.indexOf(name);
        <span class="keyword">return</span> idx &gt; -<span class="number">1</span> &amp;&amp; idx + <span class="number">1</span> &lt; argv.length ? argv[idx + <span class="number">1</span>] : (<span class="keyword">typeof</span> dflt == <span class="string">"undefined"</span> ? <span class="string">""</span> : dflt);
    },

    getArgFlag: <span class="function"><span class="keyword">function</span><span class="params">(name, dflt)</span> {</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.argv.indexOf(name) &gt; -<span class="number">1</span> ? <span class="literal">true</span> : (<span class="keyword">typeof</span> dflt != <span class="string">"undefined"</span> ? dflt : <span class="literal">false</span>);
    },

    getArgInt: <span class="function"><span class="keyword">function</span><span class="params">(name, dflt)</span> {</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.toNumber(<span class="keyword">this</span>.getArg(name, dflt));
    },</pre></div>
        
      
        
        <p>Send email</p>

        
          <div class='highlight'><pre>    sendmail: <span class="function"><span class="keyword">function</span><span class="params">(from, to, subject, text, callback)</span> {</span>
        <span class="keyword">var</span> server = emailjs.server.connect();
        server.send({ text: text || <span class="string">''</span>, from: from, to: to + <span class="string">","</span>, subject: subject || <span class="string">''</span>}, <span class="function"><span class="keyword">function</span><span class="params">(err, message)</span> {</span>
             <span class="keyword">if</span> (err) logger.error(<span class="string">'sendmail:'</span>, err);
             <span class="keyword">if</span> (message) logger.debug(<span class="string">'sendmail:'</span>, message);
             <span class="keyword">if</span> (callback) callback(err);
         });
    },</pre></div>
        
      
        
        <p>Call callback for each line in the file
options may specify the following parameters:</p>
<ul>
<li>sync - read file synchorously and call callback for every line</li>
<li>abort - signal to stop processing</li>
<li>limit - number of lines to process and exit</li>
<li>progress - if &gt; 0 report how many lines processed so far evert specified lines</li>
<li>until - skip lines until this regexp matches</li>
</ul>

        
          <div class='highlight'><pre>    forEachLine: <span class="function"><span class="keyword">function</span><span class="params">(file, options, lineCallback, endCallback)</span> {</span>
        <span class="keyword">if</span> (!options) options = {};
        <span class="keyword">var</span> buffer = <span class="keyword">new</span> Buffer(<span class="number">4096</span>);
        <span class="keyword">var</span> data = <span class="string">''</span>;
        options.lines = <span class="number">0</span>;

        <span class="function"><span class="keyword">function</span> <span class="title">readData</span><span class="params">(fd, pos, finish)</span> {</span>
            fs.read(fd, buffer, <span class="number">0</span>, buffer.length, pos, <span class="function"><span class="keyword">function</span><span class="params">(err, nread, buf)</span> {</span>
                data += buffer.slice(<span class="number">0</span>, nread).toString(options.encoding || <span class="string">'utf8'</span>);
                <span class="keyword">var</span> lines = data.split(<span class="string">"\n"</span>);
                data = lines.pop();
                async.forEachSeries(lines, <span class="function"><span class="keyword">function</span><span class="params">(line, next)</span> {</span>
                    options.lines++;
                    <span class="keyword">if</span> (options.progress &amp;&amp; options.lines % options.progress == <span class="number">0</span>) logger.log(<span class="string">'forEachLine:'</span>, file, <span class="string">'lines:'</span>, options.lines);</pre></div>
        
      
        
        <p>Skip lines until we see our pattern</p>

        
          <div class='highlight'><pre>                    <span class="keyword">if</span> (options.until &amp;&amp; !options.until_seen) {
                        options.until_seen = line.match(options.until);
                        <span class="keyword">return</span> next();
                    }
                    lineCallback(line.trim(), next);
                }, <span class="function"><span class="keyword">function</span><span class="params">(err2)</span> {</span></pre></div>
        
      
        
        <p>Stop on reaching limit or end of file</p>

        
          <div class='highlight'><pre>                    <span class="keyword">if</span> (options.abort || (options.limit &amp;&amp; options.lines &gt;= options.limit) || nread &lt; buffer.length) <span class="keyword">return</span> finish(err2);
                    setImmediate(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> readData(fd, <span class="literal">null</span>, finish); });
                });
            });
        }

        fs.open(file, <span class="string">'r'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err, fd)</span> {</span>
            <span class="keyword">if</span> (err) {
                logger.error(<span class="string">'forEachLine:'</span>, file, err);
                <span class="keyword">return</span> (endCallback ? endCallback(err) : <span class="literal">null</span>);
            }</pre></div>
        
      
        
        <p>Synchronous version, read every line and call callback which may not do any async operations
because they will not be executed right away buty only after all lines processed</p>

        
          <div class='highlight'><pre>            <span class="keyword">if</span> (options.sync) {
                <span class="keyword">while</span> (!options.abort) {
                    <span class="keyword">var</span> nread = fs.readSync(fd, buffer, <span class="number">0</span>, buffer.length, options.lines == <span class="number">0</span> ? options.start : <span class="literal">null</span>);
                    data += buffer.slice(<span class="number">0</span>, nread).toString(options.encoding || <span class="string">'utf8'</span>);
                    <span class="keyword">var</span> lines = data.split(<span class="string">"\n"</span>);
                    data = lines.pop();
                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lines.length; i++) {
                        options.lines++;
                        <span class="keyword">if</span> (options.progress &amp;&amp; options.lines % options.progress == <span class="number">0</span>) logger.log(<span class="string">'forEachLine:'</span>, file, <span class="string">'lines:'</span>, options.lines);</pre></div>
        
      
        
        <p>Skip lines until we see our pattern</p>

        
          <div class='highlight'><pre>                        <span class="keyword">if</span> (options.until &amp;&amp; !options.until_seen) {
                            options.until_seen = lines[i].match(options.until);
                            <span class="keyword">continue</span>;
                        }
                        lineCallback(lines[i].trim());
                    }</pre></div>
        
      
        
        <p>Stop on reaching limit or end of file</p>

        
          <div class='highlight'><pre>                    <span class="keyword">if</span> (nread &lt; buffer.length) <span class="keyword">break</span>;
                    <span class="keyword">if</span> (options.limit &amp;&amp; options.lines &gt;= options.limit) <span class="keyword">break</span>;
                }
                fs.close(fd, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>});
                <span class="keyword">return</span> (endCallback ? endCallback() : <span class="literal">null</span>);
            }</pre></div>
        
      
        
        <p>Start reding data from the optional position or from the beginning</p>

        
          <div class='highlight'><pre>            readData(fd, options.start, <span class="function"><span class="keyword">function</span><span class="params">(err2)</span> {</span>
                fs.close(fd, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>});
                <span class="keyword">return</span> (endCallback ? endCallback() : <span class="literal">null</span>);
            });
        });
    },</pre></div>
        
      
        
        <p>Encrypt data with the given key code</p>

        
          <div class='highlight'><pre>    encrypt: <span class="function"><span class="keyword">function</span><span class="params">(key, data, algorithm)</span> {</span>
        <span class="keyword">if</span> (!key || !data) <span class="keyword">return</span> <span class="string">''</span>;
        <span class="keyword">var</span> encrypt = crypto.createCipher(algorithm || <span class="string">'aes192'</span>, key);
        <span class="keyword">var</span> b64 = encrypt.update(String(data), <span class="string">'utf8'</span>, <span class="string">'base64'</span>);
        <span class="keyword">try</span> { b64 += encrypt.final(<span class="string">'base64'</span>); } <span class="keyword">catch</span>(e) { hex = <span class="string">''</span>; logger.error(<span class="string">'encrypt:'</span>, e); }
        <span class="keyword">return</span> b64;
    },</pre></div>
        
      
        
        <p>Decrypt data with the given key code</p>

        
          <div class='highlight'><pre>    decrypt: <span class="function"><span class="keyword">function</span><span class="params">(key, data, algorithm)</span> {</span>
        <span class="keyword">if</span> (!key || !data) <span class="keyword">return</span> <span class="string">''</span>;
        <span class="keyword">var</span> decrypt = crypto.createDecipher(algorithm || <span class="string">'aes192'</span>, key);
        <span class="keyword">var</span> msg = decrypt.update(String(data), <span class="string">'base64'</span>, <span class="string">'utf8'</span>);
        <span class="keyword">try</span> { msg += decrypt.final(<span class="string">'utf8'</span>); } <span class="keyword">catch</span>(e) { msg = <span class="string">''</span>; logger.error(<span class="string">'decrypt:'</span>, e); }
        <span class="keyword">return</span> msg;
    },</pre></div>
        
      
        
        <p>HMAC signing and base64 encoded, default algorithm is sha1</p>

        
          <div class='highlight'><pre>    sign: <span class="function"><span class="keyword">function</span> <span class="params">(key, data, algorithm, encode)</span> {</span>
        <span class="keyword">return</span> crypto.createHmac(algorithm || <span class="string">"sha1"</span>, key).update(String(data), <span class="string">"utf8"</span>).digest(encode || <span class="string">"base64"</span>);
    },</pre></div>
        
      
        
        <p>Hash and base64 encoded, default algorithm is sha1</p>

        
          <div class='highlight'><pre>    hash: <span class="function"><span class="keyword">function</span> <span class="params">(data, algorithm, encode)</span> {</span>
        <span class="keyword">return</span> crypto.createHash(algorithm || <span class="string">"sha1"</span>).update(String(data), <span class="string">"utf8"</span>).digest(encode || <span class="string">"base64"</span>);
    },</pre></div>
        
      
        
        <p>Generate random key, size if specified defines how many random bits to generate</p>

        
          <div class='highlight'><pre>    random: <span class="function"><span class="keyword">function</span><span class="params">(size)</span> {</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.sign(crypto.randomBytes(<span class="number">64</span>), crypto.randomBytes(size || <span class="number">256</span>), <span class="string">'sha256'</span>).replace(<span class="regexp">/[=+%]/g</span>, <span class="string">''</span>);
    },</pre></div>
        
      
        
        <p>Return random integer between min and max inclusive</p>

        
          <div class='highlight'><pre>    randomInt: <span class="function"><span class="keyword">function</span><span class="params">(min, max)</span> {</span>
        <span class="keyword">return</span> min + (<span class="number">0</span> | Math.random() * (max - min + <span class="number">1</span>));
    },</pre></div>
        
      
        
        <p>Return number between min and max inclusive</p>

        
          <div class='highlight'><pre>    randomNum: <span class="function"><span class="keyword">function</span><span class="params">(min, max)</span> {</span>
        <span class="keyword">return</span> min + (Math.random() * (max - min));
    },</pre></div>
        
      
        
        <p>Return number of seconds for current time</p>

        
          <div class='highlight'><pre>    now: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> Math.round((<span class="keyword">new</span> Date()).getTime()/<span class="number">1000</span>);
    },</pre></div>
        
      
        
        <p>Shortcut for current time in milliseconds</p>

        
          <div class='highlight'><pre>    mnow: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> (<span class="keyword">new</span> Date()).getTime();
    },</pre></div>
        
      
        
        <p>Format date object</p>

        
          <div class='highlight'><pre>    strftime: <span class="function"><span class="keyword">function</span><span class="params">(date, fmt, utc)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">typeof</span> date == <span class="string">"string"</span>) <span class="keyword">try</span> { date = <span class="keyword">new</span> Date(date); } <span class="keyword">catch</span>(e) {}
        <span class="keyword">if</span> (!date || isNaN(date)) <span class="keyword">return</span> <span class="string">""</span>;
        <span class="function"><span class="keyword">function</span> <span class="title">zeropad</span><span class="params">(n)</span> {</span> <span class="keyword">return</span> n &gt; <span class="number">9</span> ? n : <span class="string">'0'</span> + n; }
        <span class="keyword">var</span> handlers = {
            a : <span class="function"><span class="keyword">function</span><span class="params">(t)</span> {</span> <span class="keyword">return</span> [ <span class="string">'Sun'</span>, <span class="string">'Mon'</span>, <span class="string">'Tue'</span>, <span class="string">'Wed'</span>, <span class="string">'Thu'</span>, <span class="string">'Fri'</span>, <span class="string">'Sat'</span> ][utc ? t.getUTCDay() : t.getDay()] },
            A : <span class="function"><span class="keyword">function</span><span class="params">(t)</span> {</span> <span class="keyword">return</span> [ <span class="string">'Sunday'</span>, <span class="string">'Monday'</span>, <span class="string">'Tuedsay'</span>, <span class="string">'Wednesday'</span>, <span class="string">'Thursday'</span>, <span class="string">'Friday'</span>, <span class="string">'Saturday'</span> ][utc ? t.getUTCDay() : t.getDay()] },
            b : <span class="function"><span class="keyword">function</span><span class="params">(t)</span> {</span> <span class="keyword">return</span> [ <span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>, <span class="string">'May'</span>, <span class="string">'Jun'</span>, <span class="string">'Jul'</span>, <span class="string">'Aug'</span>, <span class="string">'Sep'</span>, <span class="string">'Oct'</span>, <span class="string">'Nov'</span>, <span class="string">'Dec'</span> ][utc ? t.getUTCMonth() : t.getMonth()] },
            B : <span class="function"><span class="keyword">function</span><span class="params">(t)</span> {</span> <span class="keyword">return</span> [ <span class="string">'January'</span>, <span class="string">'February'</span>, <span class="string">'March'</span>, <span class="string">'April'</span>, <span class="string">'May'</span>, <span class="string">'June'</span>, <span class="string">'July'</span>, <span class="string">'August'</span>, <span class="string">'September'</span>, <span class="string">'October'</span>, <span class="string">'November'</span>, <span class="string">'December'</span> ][utc ? t.getUTCMonth() : t.getMonth()] },
            c : <span class="function"><span class="keyword">function</span><span class="params">(t)</span> {</span> <span class="keyword">return</span> utc ? t.toUTCString() : t.toString() },
            d : <span class="function"><span class="keyword">function</span><span class="params">(t)</span> {</span> <span class="keyword">return</span> zeropad(utc ? t.getUTCDate() : t.getDate()) },
            H : <span class="function"><span class="keyword">function</span><span class="params">(t)</span> {</span> <span class="keyword">return</span> zeropad(utc ? t.getUTCHours() : t.getHours()) },
            I : <span class="function"><span class="keyword">function</span><span class="params">(t)</span> {</span> <span class="keyword">return</span> zeropad(((utc ? t.getUTCHours() : t.getHours()) + <span class="number">12</span>) % <span class="number">12</span>) },
            m : <span class="function"><span class="keyword">function</span><span class="params">(t)</span> {</span> <span class="keyword">return</span> zeropad((utc ? t.getUTCMonth() : t.getMonth()) + <span class="number">1</span>) }, <span class="comment">// month-1</span>
            M : <span class="function"><span class="keyword">function</span><span class="params">(t)</span> {</span> <span class="keyword">return</span> zeropad(utc ? t.getUTCMinutes() : t.getMinutes()) },
            p : <span class="function"><span class="keyword">function</span><span class="params">(t)</span> {</span> <span class="keyword">return</span> <span class="keyword">this</span>.H(t) &lt; <span class="number">12</span> ? <span class="string">'AM'</span> : <span class="string">'PM'</span>; },
            S : <span class="function"><span class="keyword">function</span><span class="params">(t)</span> {</span> <span class="keyword">return</span> zeropad(utc ? t.getUTCSeconds() : t.getSeconds()) },
            w : <span class="function"><span class="keyword">function</span><span class="params">(t)</span> {</span> <span class="keyword">return</span> utc ? t.getUTCDay() : t.getDay() }, <span class="comment">// 0..6 == sun..sat</span>
            W : <span class="function"><span class="keyword">function</span><span class="params">(t)</span> {</span> <span class="keyword">var</span> d = utc ? Date.UTC(utc ? t.getUTCFullYear() : t.getFullYear(), <span class="number">0</span>, <span class="number">1</span>) : <span class="keyword">new</span> Date(t.getFullYear(), <span class="number">0</span>, <span class="number">1</span>); <span class="keyword">return</span> Math.ceil((((t - d) / <span class="number">86400000</span>) + d.getDay() + <span class="number">1</span>) / <span class="number">7</span>); },
            y : <span class="function"><span class="keyword">function</span><span class="params">(t)</span> {</span> <span class="keyword">return</span> zeropad(<span class="keyword">this</span>.Y(t) % <span class="number">100</span>); },
            Y : <span class="function"><span class="keyword">function</span><span class="params">(t)</span> {</span> <span class="keyword">return</span> utc ? t.getUTCFullYear() : t.getFullYear() },
            t : <span class="function"><span class="keyword">function</span><span class="params">(t)</span> {</span> <span class="keyword">return</span> t.getTime() },
            u : <span class="function"><span class="keyword">function</span><span class="params">(t)</span> {</span> <span class="keyword">return</span> Math.floor(t.getTime()/<span class="number">1000</span>) },
            <span class="string">'%'</span> : <span class="function"><span class="keyword">function</span><span class="params">(t)</span> {</span> <span class="keyword">return</span> <span class="string">'%'</span> },
        };
        <span class="keyword">for</span> (<span class="keyword">var</span> h <span class="keyword">in</span> handlers) {
            fmt = fmt.replace(<span class="string">'%'</span> + h, handlers[h](date));
        }
        <span class="keyword">return</span> fmt;
    },</pre></div>
        
      
        
        <p>Split string into array, ignore empty items</p>

        
          <div class='highlight'><pre>    strSplit: <span class="function"><span class="keyword">function</span><span class="params">(str, sep)</span> {</span>
        <span class="keyword">if</span> (!str) <span class="keyword">return</span> [];
        <span class="keyword">return</span> (Array.isArray(str) ? str : String(str).split(sep || <span class="regexp">/[,\|]/</span>)).map(<span class="function"><span class="keyword">function</span><span class="params">(x)</span> {</span> <span class="keyword">return</span> x.trim() }).filter(<span class="function"><span class="keyword">function</span><span class="params">(x)</span> {</span> <span class="keyword">return</span> x != <span class="string">''</span> });
    },</pre></div>
        
      
        
        <p>Split as above but keep only unique items</p>

        
          <div class='highlight'><pre>    strSplitUnique: <span class="function"><span class="keyword">function</span><span class="params">(str, sep)</span> {</span>
        <span class="keyword">var</span> rc = [];
        <span class="keyword">this</span>.strSplit(str, sep).forEach(<span class="function"><span class="keyword">function</span><span class="params">(x)</span> {</span> <span class="keyword">if</span> (!rc.some(<span class="function"><span class="keyword">function</span><span class="params">(y)</span> {</span> <span class="keyword">return</span> x.toLowerCase() == y.toLowerCase() })) rc.push(x)});
        <span class="keyword">return</span> rc;
    },</pre></div>
        
      
        
        <p>Copy file and then remove the source, do not overwrite existing file</p>

        
          <div class='highlight'><pre>    moveFile: <span class="function"><span class="keyword">function</span><span class="params">(src, dst, overwrite, callback)</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;
        <span class="keyword">if</span> (<span class="keyword">typeof</span> overwrite == <span class="string">"function"</span>) callback = overwrite, overwrite = <span class="literal">false</span>;

        <span class="function"><span class="keyword">function</span> <span class="title">copyIfFailed</span><span class="params">(err)</span> {</span>
            <span class="keyword">if</span> (!err) <span class="keyword">return</span> (callback ? callback(<span class="literal">null</span>) : <span class="literal">null</span>);
            self.copyFile(src, dst, overwrite, <span class="function"><span class="keyword">function</span><span class="params">(err2)</span> {</span>
                <span class="keyword">if</span> (!err2) {
                    fs.unlink(src, callback);
                } <span class="keyword">else</span> {
                    <span class="keyword">if</span> (callback) callback(err2);
                }
            });
        }

        logger.debug(<span class="string">'moveFile:'</span>, src, dst, overwrite);
        fs.stat(dst, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
            <span class="keyword">if</span> (!err &amp;&amp; !overwrite) <span class="keyword">return</span> cb(<span class="keyword">new</span> Error(<span class="string">"File "</span> + dst + <span class="string">" exists."</span>));
            fs.rename(src, dst, copyIfFailed);
        });
    },</pre></div>
        
      
        
        <p>Copy file, overwrite is optional flag, by default do not overwrite</p>

        
          <div class='highlight'><pre>    copyFile: <span class="function"><span class="keyword">function</span><span class="params">(src, dst, overwrite, callback)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">typeof</span> overwrite == <span class="string">"function"</span>) callback = overwrite, overwrite = <span class="literal">false</span>;

        <span class="function"><span class="keyword">function</span> <span class="title">copy</span><span class="params">(err)</span> {</span>
            <span class="keyword">var</span> ist, ost;
            <span class="keyword">if</span> (!err &amp;&amp; !overwrite) <span class="keyword">return</span> (callback ? callback(<span class="keyword">new</span> Error(<span class="string">"File "</span> + dst + <span class="string">" exists."</span>)) : <span class="literal">null</span>);
            fs.stat(src, <span class="function"><span class="keyword">function</span> <span class="params">(err2)</span> {</span>
                <span class="keyword">if</span> (err2) <span class="keyword">return</span> (callback ? callback(err2) : <span class="literal">null</span>);
                ist = fs.createReadStream(src);
                ost = fs.createWriteStream(dst);
                util.pump(ist, ost, callback);
            });
        }
        logger.debug(<span class="string">'copyFile:'</span>, src, dst, overwrite);
        fs.stat(dst, copy);
    },</pre></div>
        
      
        
        <p>Run theprocess and return all output to the callback</p>

        
          <div class='highlight'><pre>    runProcess: <span class="function"><span class="keyword">function</span><span class="params">(cmd, callback)</span> {</span>
        exec(cmd, <span class="function"><span class="keyword">function</span> <span class="params">(err, stdout, stderr)</span> {</span>
            <span class="keyword">if</span> (err) logger.error(<span class="string">'getProcessOutput:'</span>, cmd, err);
            <span class="keyword">if</span> (callback) callback(stdout, stderr);
        });
    },</pre></div>
        
      
        
        <p>Kill all backend processes that match name and not the current process</p>

        
          <div class='highlight'><pre>    killBackend: <span class="function"><span class="keyword">function</span><span class="params">(name, callback)</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;
        self.runProcess(<span class="string">"ps agx"</span>, <span class="function"><span class="keyword">function</span><span class="params">(stdout)</span> {</span>
            stdout.split(<span class="string">"\n"</span>).
                   filter(<span class="function"><span class="keyword">function</span><span class="params">(x)</span> {</span> <span class="keyword">return</span> x.match(<span class="string">"backend:"</span>) &amp;&amp; (!name || x.match(name)); }).
                   map(<span class="function"><span class="keyword">function</span><span class="params">(x)</span> {</span> <span class="keyword">return</span> self.toNumber(x) }).
                   filter(<span class="function"><span class="keyword">function</span><span class="params">(x)</span> {</span> <span class="keyword">return</span> x != process.pid }).
                   forEach(<span class="function"><span class="keyword">function</span><span class="params">(x)</span> {</span> process.kill(x) });
            <span class="keyword">if</span> (callback) callback();
        });
    },</pre></div>
        
      
        
        <p>Shutdown the machine now</p>

        
          <div class='highlight'><pre>    shutdown: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        exec(<span class="string">"/sbin/halt"</span>, <span class="function"><span class="keyword">function</span><span class="params">(err, stdout, stderr)</span> {</span>
            logger.log(<span class="string">'shutdown:'</span>, stdout || <span class="string">""</span>, stderr || <span class="string">""</span>, err || <span class="string">""</span>);
        });
    },</pre></div>
        
      
        
        <p>Non-exception version, returns empty object,
mtime is 0 in case file does not exist or number of seconds of last modified time
mdate is a Date object with last modified time</p>

        
          <div class='highlight'><pre>    statSync: <span class="function"><span class="keyword">function</span><span class="params">(file)</span> {</span>
        <span class="keyword">var</span> stat = { size: <span class="number">0</span>, mtime: <span class="number">0</span>, mdate: <span class="string">""</span>, isFile: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span><span class="keyword">return</span> <span class="literal">false</span>}, isDirectory: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span><span class="keyword">return</span> <span class="literal">false</span>} }
        <span class="keyword">try</span> {
            stat = fs.statSync(file);
            stat.mdate = stat.mtime.toISOString();
            stat.mtime = stat.mtime.getTime()/<span class="number">1000</span>;
        } <span class="keyword">catch</span>(e) {
            <span class="keyword">if</span> (e.code != <span class="string">"ENOENT"</span>) logger.error(<span class="string">'statSync:'</span>, e);
        }
        <span class="keyword">return</span> stat;
    },</pre></div>
        
      
        
        <p>Return list of files than match filter recursively starting with given path</p>

        
          <div class='highlight'><pre>    findFileSync: <span class="function"><span class="keyword">function</span><span class="params">(file, filter)</span> {</span>
        <span class="keyword">var</span> list = [];
        <span class="keyword">try</span> {
            <span class="keyword">var</span> stat = <span class="keyword">this</span>.statSync(file);
            <span class="keyword">if</span> (stat.isFile()) {
                <span class="keyword">if</span> (file != <span class="string">"."</span> &amp;&amp; file != <span class="string">".."</span> &amp;&amp; (!filter || filter(file, stat))) {
                    list.push(file);
                }
            } <span class="keyword">else</span>
            <span class="keyword">if</span> (stat.isDirectory()) {
                <span class="keyword">if</span> (file != <span class="string">"."</span> &amp;&amp; file != <span class="string">".."</span> &amp;&amp; (!filter || filter(file, stat))) {
                    list.push(file);
                }
                <span class="keyword">var</span> files = fs.readdirSync(file);
                <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> files) {
                    list = list.concat(<span class="keyword">this</span>.findFileSync(path.join(file, files[i]), filter));
                }
            }
        } <span class="keyword">catch</span>(e) {
            logger.error(<span class="string">'findFileSync:'</span>, file, e);
        }
        <span class="keyword">return</span> list;
    },</pre></div>
        
      
        
        <p>Recursively create all directries, return 1 if created</p>

        
          <div class='highlight'><pre>    makePathSync: <span class="function"><span class="keyword">function</span><span class="params">(dir)</span> {</span>
        <span class="keyword">var</span> list = path.normalize(dir).split(<span class="string">"/"</span>);
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, dir = <span class="string">''</span>; i &lt; list.length; i++) {
            dir += list[i] + <span class="string">'/'</span>;
            <span class="keyword">try</span> {
                <span class="keyword">if</span> (!fs.existsSync(dir)) fs.mkdirSync(dir);
            }
            <span class="keyword">catch</span>(e) {
                logger.error(<span class="string">'makePath:'</span>, e)
                <span class="keyword">return</span> <span class="number">0</span>;
            }
        }
        <span class="keyword">return</span> <span class="number">1</span>;
    },</pre></div>
        
      
        
        <p>Async version, stops on first error</p>

        
          <div class='highlight'><pre>    makePath: <span class="function"><span class="keyword">function</span><span class="params">(dir, callback)</span> {</span>
        <span class="keyword">var</span> list = path.normalize(dir).split(<span class="string">"/"</span>);
        <span class="keyword">var</span> full = <span class="string">""</span>;
        async.forEachSeries(list, <span class="function"><span class="keyword">function</span><span class="params">(d, next)</span> {</span>
            full += d + <span class="string">'/'</span>;
            fs.exists(full, <span class="function"><span class="keyword">function</span><span class="params">(yes)</span> {</span>
                <span class="keyword">if</span> (yes) <span class="keyword">return</span> next();
                fs.mkdir(full, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> {</span>
                    next(err &amp;&amp; err.code != <span class="string">'EEXIST'</span> &amp;&amp; err.code != <span class="string">'EISDIR'</span> ? err : <span class="literal">null</span>);
                });
            });
        }, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> {</span>
            <span class="keyword">if</span> (err) logger.error(<span class="string">'makePath:'</span>, err);
            <span class="keyword">if</span> (callback) callback(err);
        });
    },</pre></div>
        
      
        
        <p>Change file owner do not report errors about non existent files</p>

        
          <div class='highlight'><pre>    chownSync: <span class="function"><span class="keyword">function</span><span class="params">(file)</span> {</span>
        <span class="keyword">try</span> {
            fs.chownSync(file, <span class="keyword">this</span>.uid, <span class="keyword">this</span>.gid);
        } <span class="keyword">catch</span>(e) {
            <span class="keyword">if</span> (e.code != <span class="string">'ENOENT'</span>) logger.error(<span class="string">'chownSync:'</span>, <span class="keyword">this</span>.uid, <span class="keyword">this</span>.gid, file, e);
        }
    },</pre></div>
        
      
        
        <p>Create a directory if does not exist</p>

        
          <div class='highlight'><pre>    mkdirSync: <span class="function"><span class="keyword">function</span><span class="params">(dir)</span> {</span>
        <span class="keyword">if</span> (!fs.existsSync(dir)) {
            <span class="keyword">try</span> { fs.mkdirSync(dir) } <span class="keyword">catch</span>(e) { logger.error(<span class="string">'mkdirSync:'</span>, dir, e) }
        }
    },</pre></div>
        
      
        
        <p>Drop root privileges and switch to regular user</p>

        
          <div class='highlight'><pre>    dropPrivileges: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">if</span> (process.getuid() == <span class="number">0</span>) {
            logger.debug(<span class="string">'init: switching to'</span>, core.uid, core.gid);
            <span class="keyword">try</span> { process.setgid(core.gid); } <span class="keyword">catch</span>(e) { logger.error(<span class="string">'setgid:'</span>, core.gid, e); }
            <span class="keyword">try</span> { process.setuid(core.uid); } <span class="keyword">catch</span>(e) { logger.error(<span class="string">'setuid:'</span>, core.uid, e); }
        }
    },</pre></div>
        
      
        
        <p>Set or reset a timer</p>

        
          <div class='highlight'><pre>    setTimeout: <span class="function"><span class="keyword">function</span><span class="params">(name, callback, timeout)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.timers[name]) clearTimeout(<span class="keyword">this</span>.timers[name]);
        <span class="keyword">this</span>.timers[name] = setTimeout(callback, timeout);    
    },</pre></div>
        
      
        
        <p>Full path to the icon, perform necessary hashing and sharding, id can be a number or any string</p>

        
          <div class='highlight'><pre>    iconPath: <span class="function"><span class="keyword">function</span><span class="params">(id, options)</span> {</span>
        <span class="keyword">if</span> (!options) options = {};</pre></div>
        
      
        
        <p>Convert into string and remove all chars except numbers, this will support UUIDs as well as regulat integers</p>

        
          <div class='highlight'><pre>        id = String(id).replace(<span class="regexp">/[^0-9]/g</span>, <span class="string">''</span>);
        <span class="keyword">return</span> path.join(<span class="keyword">this</span>.path.images, options.prefix || <span class="string">""</span>, id.substr(-<span class="number">2</span>), id.substr(-<span class="number">4</span>, <span class="number">2</span>), (options.type ? String(options.type)[<span class="number">0</span>] : <span class="string">""</span>) + id + <span class="string">"."</span> + (options.ext || <span class="string">"jpg"</span>));
    },</pre></div>
        
      
        
        <p>Download image and convert into JPG, store under core.path.images
Options may be controlled using the properties:</p>
<ul>
<li>force - force rescaling for all types even if already exists</li>
<li>type - type for the icon, prepended to the icon id</li>
<li>prefix - where to store all scaled icons</li>
<li>verify - check if the original icon is the same as at the source</li>
</ul>

        
          <div class='highlight'><pre>    getIcon: <span class="function"><span class="keyword">function</span><span class="params">(uri, id, options, callback)</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;

        <span class="keyword">if</span> (<span class="keyword">typeof</span> options == <span class="string">"function"</span>) callback = options, options = <span class="literal">null</span>;
        <span class="keyword">if</span> (!options) options = {};
        logger.debug(<span class="string">'getIcon:'</span>, uri, options);

        <span class="keyword">if</span> (!uri || !id) <span class="keyword">return</span> (callback ? callback(<span class="keyword">new</span> Error(<span class="string">"wrong args"</span>)) : <span class="literal">null</span>);</pre></div>
        
      
        
        <p>Verify image size and skip download if the same</p>

        
          <div class='highlight'><pre>        <span class="keyword">if</span> (options.verify) {
            <span class="keyword">var</span> imgfile = <span class="keyword">this</span>.iconPath(id, options);
            fs.stat(imgfile, <span class="function"><span class="keyword">function</span><span class="params">(err, stats)</span> {</span>
                logger.debug(<span class="string">'getIcon:'</span>, id, imgfile, <span class="string">'stats:'</span>, stats, err);</pre></div>
        
      
        
        <p>No image, get a new one</p>

        
          <div class='highlight'><pre>                <span class="keyword">if</span> (err) <span class="keyword">return</span> self.getIcon(uri, id, self.delObj(options, <span class="string">'verify'</span>), callback);

                self.httpGet(uri, { method: <span class="string">'HEAD'</span> }, <span class="function"><span class="keyword">function</span><span class="params">(err2, params)</span> {</span>
                    logger.edebug(err2, <span class="string">'getIcon:'</span>, id, imgfile, <span class="string">'size1:'</span>, stats.size, <span class="string">'size2:'</span>, params.size);</pre></div>
        
      
        
        <p>Not the same, get a new one</p>

        
          <div class='highlight'><pre>                    <span class="keyword">if</span> (params.size !== stats.size) <span class="keyword">return</span> self.getIcon(uri, id, self.delObj(options, <span class="string">'verify'</span>), callback);</pre></div>
        
      
        
        <p>Same, just verify types</p>

        
          <div class='highlight'><pre>                    self.putIcon(imgfile, id, options, callback);
                });
            });
            <span class="keyword">return</span>;
        }</pre></div>
        
      
        
        <p>Download into temp file, make sure dir exists</p>

        
          <div class='highlight'><pre>        <span class="keyword">var</span> opts = url.parse(uri);
        <span class="keyword">var</span> tmpfile = path.join(<span class="keyword">this</span>.path.tmp, core.random().replace(<span class="regexp">/[\/=]/g</span>,<span class="string">''</span>) + path.extname(opts.pathname));
        self.httpGet(uri, { file: tmpfile }, <span class="function"><span class="keyword">function</span><span class="params">(err, params)</span> {</span></pre></div>
        
      
        
        <p>Error in downloading</p>

        
          <div class='highlight'><pre>            <span class="keyword">if</span> (err || params.status != <span class="number">200</span>) {
                fs.unlink(tmpfile, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>});
                logger.edebug(err, <span class="string">'getIcon:'</span>, id, uri, <span class="string">'not found'</span>, <span class="string">'status:'</span>, params.status);
                <span class="keyword">return</span> (callback ? callback(err || <span class="keyword">new</span> Error(<span class="string">'Status '</span> + params.status)) : <span class="literal">null</span>);
            }</pre></div>
        
      
        
        <p>Store in the proper location</p>

        
          <div class='highlight'><pre>            self.putIcon(tmpfile, id, options, <span class="function"><span class="keyword">function</span><span class="params">(err2)</span> {</span>
                fs.unlink(tmpfile, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>});
                <span class="keyword">if</span> (callback) callback(err2);
            });
        });
    },</pre></div>
        
      
        
        <p>Put original or just downloaded file in the proper location according to the types for given id,
this function is used after downloading new image or when moving images from other places
Rescale all required icons by setting force to true in the options
Valid properties in the options:</p>
<ul>
<li>type - icon type, this will be prepended to the name of the icon</li>
<li>prefix - top level subdirectory under images/</li>
<li>force - to rescale even if it already exists</li>
<li>width, height, filter, ext, quality for backend.resizeImage function</li>
</ul>

        
          <div class='highlight'><pre>    putIcon: <span class="function"><span class="keyword">function</span><span class="params">(file, id, options, callback)</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;
        <span class="keyword">if</span> (<span class="keyword">typeof</span> options == <span class="string">"function"</span>) callback = options, options = <span class="literal">null</span>;
        <span class="keyword">if</span> (!options) options = {};
        logger.debug(<span class="string">'putIcon:'</span>, id, file, options);

        <span class="keyword">var</span> image = self.iconPath(id, options);</pre></div>
        
      
        
        <p>Filesystem based icon storage, verify local disk</p>

        
          <div class='highlight'><pre>        fs.exists(image, <span class="function"><span class="keyword">function</span><span class="params">(yes)</span> {</span></pre></div>
        
      
        
        <p>Exists and we do not need to rescale</p>

        
          <div class='highlight'><pre>            <span class="keyword">if</span> (yes &amp;&amp; !options.force) <span class="keyword">return</span> callback();</pre></div>
        
      
        
        <p>Make new scaled icon</p>

        
          <div class='highlight'><pre>            self.scaleIcon(file, image, options, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> {</span>
                logger.edebug(err, <span class="string">"putIcon:"</span>, id, file, options);
                <span class="keyword">if</span> (callback) callback(err);
            });
        });
    },</pre></div>
        
      
        
        <p>Scale image using ImageMagick into a file, return err if failed</p>
<ul>
<li>infile can be a string with file name or a Buffer with actual image data</li>
<li>outfle is not empty is a file naem where to store scaled image or if empty the new image contents will be returned in the callback</li>
<li>options can specify image extension in .ext, width/height/filter/quality</li>
</ul>

        
          <div class='highlight'><pre>    scaleIcon: <span class="function"><span class="keyword">function</span><span class="params">(infile, outfile, options, callback)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">typeof</span> options == <span class="string">"function"</span>) callback = options, options = {};
        <span class="keyword">if</span> (!options) options = {};
        backend.resizeImage(infile, options.width || <span class="number">0</span>, options.height || <span class="number">0</span>, options.ext || <span class="string">"jpg"</span>, options.filter || <span class="string">"lanczos"</span>, options.quality || <span class="number">99</span>, outfile, <span class="function"><span class="keyword">function</span><span class="params">(err, data)</span> {</span>
            logger.edebug(err, <span class="string">'scaleIcon:'</span>, <span class="keyword">typeof</span> infile == <span class="string">"object"</span> ? infile.length : infile, outfile, options);
            <span class="keyword">if</span> (callback) callback(err, data);
        });
    },</pre></div>
        
      
        
        <p>Return object type, try to detect any distinguished type</p>

        
          <div class='highlight'><pre>    typeName: <span class="function"><span class="keyword">function</span><span class="params">(v)</span> {</span>
        <span class="keyword">var</span> t = <span class="keyword">typeof</span>(v);
        <span class="keyword">if</span> (v === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">"null"</span>;
        <span class="keyword">if</span> (t !== <span class="string">"object"</span>) <span class="keyword">return</span> t;
        <span class="keyword">if</span> (Array.isArray(v)) <span class="keyword">return</span> <span class="string">"array"</span>;
        <span class="keyword">if</span> (Buffer.isBuffer(v)) <span class="keyword">return</span> <span class="string">"buffer"</span>;
        <span class="keyword">if</span> (v.constructor == (<span class="keyword">new</span> Date).constructor) <span class="keyword">return</span> <span class="string">"date"</span>;
        <span class="keyword">if</span> (v.constructor == (<span class="keyword">new</span> RegExp).constructor) <span class="keyword">return</span> <span class="string">"regex"</span>;
        <span class="keyword">return</span> <span class="string">"object"</span>;
    },</pre></div>
        
      
        
        <p>Return true of the given value considered empty</p>

        
          <div class='highlight'><pre>    isEmpty: <span class="function"><span class="keyword">function</span><span class="params">(val)</span> {</span>
        <span class="keyword">switch</span> (<span class="keyword">this</span>.typeName(val)) {
        <span class="keyword">case</span> <span class="string">"null"</span>:
        <span class="keyword">case</span> <span class="string">"undefined"</span>: 
            <span class="keyword">return</span> <span class="literal">true</span>;
        <span class="keyword">case</span> <span class="string">"buffer"</span>:
        <span class="keyword">case</span> <span class="string">"array"</span>: 
            <span class="keyword">return</span> val.length == <span class="number">0</span>;
        <span class="keyword">case</span> <span class="string">"number"</span>:
        <span class="keyword">case</span> <span class="string">"regex"</span>:
        <span class="keyword">case</span> <span class="string">"boolean"</span>:
            <span class="keyword">return</span> <span class="literal">false</span>;
        <span class="keyword">case</span> <span class="string">"date"</span>:
            <span class="keyword">return</span> isNaN(val);
        <span class="keyword">default</span>:
            <span class="keyword">return</span> val ? <span class="literal">false</span>: <span class="literal">true</span>;
        }
    },</pre></div>
        
      
        
        <p>Deep copy of an object,</p>
<ul>
<li>filter is an object to skip properties that defined in it by name, 
if filter&#39;s value is boolean, skip, if integer then skip if greater in length for string properties<ul>
<li>_skip_null tells to skip all null properties</li>
<li>_empty_to_null - convert empty strings into null objects</li>
<li>_skip_cb - a callback that returns true to skip a property, argumnets are property name and value</li>
</ul>
</li>
<li>props can be used to add additional properties to the new object</li>
</ul>

        
          <div class='highlight'><pre>    cloneObj: <span class="function"><span class="keyword">function</span><span class="params">(obj, filter, props)</span> {</span>
        <span class="keyword">var</span> rc = {};
        <span class="keyword">switch</span> (<span class="keyword">this</span>.typeName(obj)) {
        <span class="keyword">case</span> <span class="string">"object"</span>:
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">"array"</span>:
            rc = [];
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">"buffer"</span>:
            <span class="keyword">return</span> <span class="keyword">new</span> Buffer(<span class="keyword">this</span>);
        <span class="keyword">case</span> <span class="string">"date"</span>:
            <span class="keyword">return</span> <span class="keyword">new</span> Date(obj.getTime());
        <span class="keyword">case</span> <span class="string">"regex"</span>:
            <span class="keyword">return</span> <span class="keyword">new</span> Regexp(<span class="keyword">this</span>);
        <span class="keyword">case</span> <span class="string">"string"</span>:
            <span class="keyword">if</span> (filter._empty_to_null &amp;&amp; obj === <span class="string">""</span>) <span class="keyword">return</span> <span class="literal">null</span>;
            <span class="keyword">return</span> obj;
        <span class="keyword">default</span>:
            <span class="keyword">return</span> obj;
        }
        <span class="keyword">if</span> (!filter) filter = {};
        <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> obj) {
            <span class="keyword">switch</span> (<span class="keyword">this</span>.typeName(filter[p])) {
            <span class="keyword">case</span> <span class="string">"undefined"</span>:
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">"number"</span>:
                <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[p] == <span class="string">"string"</span> &amp;&amp; obj[p].length &lt; filter[p]) <span class="keyword">break</span>;
                <span class="keyword">continue</span>;
            <span class="keyword">default</span>:     
               <span class="keyword">continue</span>;
            }
            <span class="keyword">if</span> ((obj[p] == <span class="literal">null</span> || <span class="keyword">typeof</span> obj[p] == <span class="string">"undefined"</span>) &amp;&amp; filter._skip_null) <span class="keyword">continue</span>;
            <span class="keyword">if</span> (filter._skip_cb &amp;&amp; filter._skip_cb(p, obj[p])) <span class="keyword">continue</span>;
            rc[p] = <span class="keyword">this</span>.cloneObj(obj[p], filter);
        }
        <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> props) rc[p] = props[p];
        <span class="keyword">return</span> rc;
    },</pre></div>
        
      
        
        <p>Return new object using arguments as name value pairs for new object properties</p>

        
          <div class='highlight'><pre>    newObj: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> obj = {};
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arguments.length - <span class="number">1</span>; i += <span class="number">2</span>) obj[arguments[i]] = arguments[i + <span class="number">1</span>];
        <span class="keyword">return</span> obj;
    },</pre></div>
        
      
        
        <p>Add properties to existing object, first arg is the object, the rest are pairs: name, value,....</p>

        
          <div class='highlight'><pre>    extendObj: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">typeof</span> arguments[<span class="number">0</span>] != <span class="string">"object"</span>) <span class="keyword">return</span>;
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arguments.length - <span class="number">1</span>; i += <span class="number">2</span>) arguments[<span class="number">0</span>][arguments[i]] = arguments[i + <span class="number">1</span>];
        <span class="keyword">return</span> arguments[<span class="number">0</span>];
    },</pre></div>
        
      
        
        <p>Delete properties from the object, first arg is an object, the rest are properties to be deleted</p>

        
          <div class='highlight'><pre>    delObj: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">typeof</span> arguments[<span class="number">0</span>] != <span class="string">"object"</span>) <span class="keyword">return</span>;
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arguments.length; i++) <span class="keyword">delete</span> arguments[<span class="number">0</span>][arguments[i]];
        <span class="keyword">return</span> arguments[<span class="number">0</span>];
    },</pre></div>
        
      
        
        <p>JSON stringify without empty properties</p>

        
          <div class='highlight'><pre>    stringify: <span class="function"><span class="keyword">function</span><span class="params">(obj)</span> {</span>
        <span class="keyword">return</span> JSON.stringify(<span class="keyword">this</span>.cloneObj(obj, { _skip_null: <span class="number">1</span>, _skip_cb: <span class="function"><span class="keyword">function</span><span class="params">(n,v)</span> {</span> <span class="keyword">return</span> v == <span class="string">""</span> } }));
    },</pre></div>
        
      
        
        <p>Return cookies that match given domain</p>

        
          <div class='highlight'><pre>    cookieGet: <span class="function"><span class="keyword">function</span><span class="params">(domain, callback)</span> {</span>
        <span class="keyword">this</span>.context.db.select(<span class="string">"backend_cookies"</span>, {}, <span class="function"><span class="keyword">function</span><span class="params">(err, rows)</span> {</span>
            <span class="keyword">var</span> cookies = [];
            rows.forEach(<span class="function"><span class="keyword">function</span><span class="params">(cookie)</span> {</span>
                <span class="keyword">if</span> (cookie.expires &lt;= Date.now()) <span class="keyword">return</span>;
                <span class="keyword">if</span> (cookie.domain == domain) {
                    cookies.push(cookie);
                } <span class="keyword">else</span>
                <span class="keyword">if</span> (cookie.domain.charAt(<span class="number">0</span>) == <span class="string">"."</span> &amp;&amp; (cookie.domain.substr(<span class="number">1</span>) == domain || domain.match(cookie.domain.replace(<span class="regexp">/\./g</span>,<span class="string">'\\.'</span>) + <span class="string">'$'</span>))) {
                    cookies.push(cookie);
                }
            });
            logger.debug(<span class="string">'cookieGet:'</span>, domain, cookies);
            <span class="keyword">if</span> (callback) callback(cookies);
        });
    },</pre></div>
        
      
        
        <p>Save new cookies arrived in the request, 
merge with existing cookies from the jar which is a list of cookies before the request</p>

        
          <div class='highlight'><pre>    cookieSave: <span class="function"><span class="keyword">function</span><span class="params">(cookiejar, setcookies, hostname, callback)</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;
        <span class="keyword">var</span> cookies = !setcookies ? [] : Array.isArray(setcookies) ? setcookies : String(setcookies).split(<span class="regexp">/[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g</span>);
        logger.debug(<span class="string">'cookieSave:'</span>, cookiejar, <span class="string">'SET:'</span>, cookies);
        cookies.forEach(<span class="function"><span class="keyword">function</span><span class="params">(cookie)</span> {</span>
            <span class="keyword">var</span> parts = cookie.split(<span class="string">";"</span>);
            <span class="keyword">var</span> pair = parts[<span class="number">0</span>].match(<span class="regexp">/([^=]+)=((?:.|\n)*)/</span>);
            <span class="keyword">if</span> (!pair) <span class="keyword">return</span>;
            <span class="keyword">var</span> obj = { name: pair[<span class="number">1</span>], value: pair[<span class="number">2</span>], path: <span class="string">""</span>, domain: <span class="string">""</span>, secure: <span class="literal">false</span>, expires: <span class="literal">Infinity</span> };
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; parts.length; i++) {
                pair = parts[i].match(<span class="regexp">/([^=]+)(?:=((?:.|\n)*))?/</span>);
                <span class="keyword">if</span> (!pair) <span class="keyword">continue</span>;
                <span class="keyword">var</span> key = pair[<span class="number">1</span>].trim().toLowerCase();
                <span class="keyword">var</span> value = pair[<span class="number">2</span>];
                <span class="keyword">switch</span>(key) {
                <span class="keyword">case</span> <span class="string">"expires"</span>:
                    obj.expires = value ? Number(self.toDate(value)) : <span class="literal">Infinity</span>;
                    <span class="keyword">break</span>;

                <span class="keyword">case</span> <span class="string">"path"</span>:
                    obj.path = value ? value.trim() : <span class="string">""</span>;
                    <span class="keyword">break</span>;

                <span class="keyword">case</span> <span class="string">"domain"</span>:
                    obj.domain = value ? value.trim() : <span class="string">""</span>;
                    <span class="keyword">break</span>;

                <span class="keyword">case</span> <span class="string">"secure"</span>:
                    obj.secure = <span class="literal">true</span>;
                    <span class="keyword">break</span>;
                }
            }
            <span class="keyword">if</span> (!obj.domain) obj.domain = hostname || <span class="string">""</span>;
            <span class="keyword">var</span> found = <span class="literal">false</span>;
            cookiejar.forEach(<span class="function"><span class="keyword">function</span><span class="params">(x, j)</span> {</span>
                <span class="keyword">if</span> (x.path == obj.path &amp;&amp; x.domain == obj.domain &amp;&amp; x.name == obj.name) {
                    <span class="keyword">if</span> (obj.expires &lt;= Date.now()) {
                        cookiejar[j] = <span class="literal">null</span>;
                    } <span class="keyword">else</span> {
                        cookiejar[j] = obj;
                    }
                    found = <span class="literal">true</span>;
                }
            });
            <span class="keyword">if</span> (!found) cookiejar.push(obj);
        });
        async.forEachSeries(cookiejar, <span class="function"><span class="keyword">function</span><span class="params">(rec, next)</span> {</span>
            <span class="keyword">if</span> (!rec) <span class="keyword">return</span> next();
            self.context.db.put(<span class="string">"backend_cookies"</span>, rec, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> next() });
        }, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            <span class="keyword">if</span> (callback) callback();
        });
    },</pre></div>
        
      
        
        <p>Adds reference to the object in the core for further access</p>

        
          <div class='highlight'><pre>    addContext: <span class="function"><span class="keyword">function</span><span class="params">(name, obj)</span> {</span>
        <span class="keyword">this</span>.context[name] = obj;
    },</pre></div>
        
      
        
        <p>Create REPL interface with all modules available</p>

        
          <div class='highlight'><pre>    createRepl: <span class="function"><span class="keyword">function</span><span class="params">(options)</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;
        <span class="keyword">var</span> r = repl.start(options || {});
        r.context.core = <span class="keyword">this</span>;
        r.context.logger = logger;
        r.context.backend = backend;
        r.context.fs = fs;
        r.context.os = os;
        r.context.util = util;
        r.rli.historyIndex = <span class="number">0</span>;
        r.rli.history = [];</pre></div>
        
      
        
        <p>Expose all modules as top level objects</p>

        
          <div class='highlight'><pre>        <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> <span class="keyword">this</span>.context) r.context[p] = <span class="keyword">this</span>.context[p];</pre></div>
        
      
        
        <p>Support history</p>

        
          <div class='highlight'><pre>        <span class="keyword">if</span> (<span class="keyword">this</span>.replFile) {
            <span class="keyword">try</span> {
                r.rli.history = fs.readFileSync(<span class="keyword">this</span>.replFile, <span class="string">'utf-8'</span>).split(<span class="string">'\n'</span>).reverse();
            } <span class="keyword">catch</span> (e) {}

            r.rli.addListener(<span class="string">'line'</span>, <span class="function"><span class="keyword">function</span><span class="params">(code)</span> {</span>
                <span class="keyword">if</span> (code) {
                    fs.appendFile(self.replFile, code + <span class="string">'\n'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>});
                } <span class="keyword">else</span> {
                    r.rli.historyIndex++;
                    r.rli.history.pop();
                }
          });
        }
        <span class="keyword">return</span> r;
    },</pre></div>
        
      
        
        <p>Watch temp files and remove files that are older than given number of seconds since now, remove only files that match pattern if given
This function is not async-safe, it uses sync calls</p>

        
          <div class='highlight'><pre>    watchTmp: <span class="function"><span class="keyword">function</span><span class="params">(dirs, secs, pattern)</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;
        <span class="keyword">var</span> now = core.now();
        (dirs || []).forEach(<span class="function"><span class="keyword">function</span><span class="params">(dir)</span> {</span>
            self.findFileSync(dir, <span class="function"><span class="keyword">function</span><span class="params">(f, s)</span> {</span>
                <span class="keyword">if</span> (pattern &amp;&amp; !f.match(patern)) <span class="keyword">return</span> <span class="literal">false</span>;
                <span class="keyword">if</span> (!s.mtime || now - s.mtime &lt; secs || s.isDirectory()) <span class="keyword">return</span> <span class="literal">false</span>;
                logger.log(<span class="string">'watchTmp: delete'</span>, dir, f, (now - s.mtime)/<span class="number">60</span>, <span class="string">'mins old'</span>);
                <span class="keyword">return</span> <span class="literal">true</span>;
            }).forEach(<span class="function"><span class="keyword">function</span><span class="params">(file)</span> {</span>
                fs.unlink(file, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> {</span>
                    <span class="keyword">if</span> (err) logger.error(<span class="string">'watchTmp:'</span>, file, err);
                });
            });
        });
    },</pre></div>
        
      
        
        <p>Watch files in a dir for changes and call the callback</p>

        
          <div class='highlight'><pre>    watchFiles: <span class="function"><span class="keyword">function</span><span class="params">(dir, pattern, callback)</span> {</span>
        logger.debug(<span class="string">'watchFiles:'</span>, dir, pattern);
        fs.readdirSync(dir).filter(<span class="function"><span class="keyword">function</span><span class="params">(file)</span> {</span> 
            <span class="keyword">return</span> file.match(pattern);
        }).map(<span class="function"><span class="keyword">function</span><span class="params">(file)</span> {</span>
            file = path.join(dir, file);
            <span class="keyword">return</span> ({ name: file, stat: core.statSync(file) });
        }).forEach(<span class="function"><span class="keyword">function</span><span class="params">(file)</span> {</span>
            logger.debug(<span class="string">'watchFiles:'</span>, file.name, file.stat.size);
            fs.watch(file.name, <span class="function"><span class="keyword">function</span><span class="params">(event, filename)</span> {</span></pre></div>
        
      
        
        <p>Check stat if no file name, Mac OSX does not provide it</p>

        
          <div class='highlight'><pre>                <span class="keyword">if</span> (!filename &amp;&amp; core.statSync(file.name).size == file.stat.size) <span class="keyword">return</span>;
                logger.log(<span class="string">'watchFiles:'</span>, event, filename || file.name); 
                callback(file);
            });
        });     
    },</pre></div>
        
      
        
        <p>Watch log files for errors and report via email</p>

        
          <div class='highlight'><pre>    watchLogs: <span class="function"><span class="keyword">function</span><span class="params">(callback)</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;</pre></div>
        
      
        
        <p>Need email to send</p>

        
          <div class='highlight'><pre>        <span class="keyword">if</span> (!self.logwatcherEmail) <span class="keyword">return</span> (callback ? callback() : <span class="literal">false</span>);</pre></div>
        
      
        
        <p>From address, use current hostname</p>

        
          <div class='highlight'><pre>        <span class="keyword">if</span> (!self.logwatcherFrom) self.logwatcherFrom = <span class="string">"logwatcher@"</span> + (self.domain || os.hostname());</pre></div>
        
      
        
        <p>Check interval</p>

        
          <div class='highlight'><pre>        <span class="keyword">var</span> now = <span class="keyword">new</span> Date();
        <span class="keyword">if</span> (self.logwatcherMtime &amp;&amp; (now.getTime() - self.logwatcherMtime.getTime())/<span class="number">1000</span> &lt; self.logwatcherInterval) <span class="keyword">return</span>;
        self.logwatcherMtime = now;

        <span class="keyword">var</span> match = <span class="literal">null</span>;
        <span class="keyword">if</span> (self.logwatcherMatch) {
            <span class="keyword">try</span> { match = <span class="keyword">new</span> RegExp(self.logwatcherIgnore); } <span class="keyword">catch</span>(e) {}
        }
        <span class="keyword">var</span> ignore = <span class="literal">null</span>
        <span class="keyword">if</span> (self.logwatcherIgnore) {
            <span class="keyword">try</span> { ignore = <span class="keyword">new</span> RegExp(self.logwatcherIgnore); } <span class="keyword">catch</span>(e) {}
        }
        <span class="keyword">var</span> db = self.context.db;</pre></div>
        
      
        
        <p>Load all previous positions for every log file, we start parsing file from the previous last stop</p>

        
          <div class='highlight'><pre>        db.query(<span class="string">"SELECT * FROM backend_property WHERE name LIKE 'logwatcher:%'"</span>, <span class="function"><span class="keyword">function</span><span class="params">(err, rows)</span> {</span>
            <span class="keyword">var</span> lastpos = {};
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; rows.length; i++) {
                lastpos[rows[i].name] = rows[i].value;
            }
            <span class="keyword">var</span> errors = <span class="string">""</span>;</pre></div>
        
      
        
        <p>For every log file</p>

        
          <div class='highlight'><pre>            async.forEachSeries(self.logwatcherFiles, <span class="function"><span class="keyword">function</span><span class="params">(log, next)</span> {</span>
                <span class="keyword">var</span> file = log.file;
                <span class="keyword">if</span> (!file &amp;&amp; self[log.name]) file = self[log.name];
                <span class="keyword">if</span> (!file) <span class="keyword">return</span> next();

                fs.stat(file, <span class="function"><span class="keyword">function</span><span class="params">(err2, st)</span> {</span>
                   <span class="keyword">if</span> (err2) <span class="keyword">return</span> next();</pre></div>
        
      
        
        <p>Last saved position, start from the end if the log file is too big or got rotated</p>

        
          <div class='highlight'><pre>                   <span class="keyword">var</span> pos = core.toNumber(lastpos[<span class="string">'logwatcher:'</span> + file] || <span class="number">0</span>);
                   <span class="keyword">if</span> (st.size - pos &gt; self.logwatcherMax || pos &gt; st.size) pos = st.size - self.logwatcherMax;

                   fs.open(file, <span class="string">"r"</span>, <span class="function"><span class="keyword">function</span><span class="params">(err3, fd)</span> {</span>
                       <span class="keyword">if</span> (err3) <span class="keyword">return</span> next();
                       <span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(self.logwatcherMax);
                       fs.read(fd, buf, <span class="number">0</span>, buf.length, Math.max(<span class="number">0</span>, pos), <span class="function"><span class="keyword">function</span><span class="params">(err4, nread, buffer)</span> {</span>
                           fs.close(fd, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>});
                           <span class="keyword">if</span> (err4 || !nread) {
                               fs.close(fd, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>});
                               <span class="keyword">return</span> next();
                           }
                           <span class="keyword">var</span> lines = buffer.slice(<span class="number">0</span>, nread).toString().split(<span class="string">"\n"</span>);
                           <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> lines) {</pre></div>
        
      
        
        <p>Skip global ignore list first</p>

        
          <div class='highlight'><pre>                               <span class="keyword">if</span> (ignore &amp;&amp; ignore.test(lines[i])) <span class="keyword">continue</span>;</pre></div>
        
      
        
        <p>Match either global or local filter</p>

        
          <div class='highlight'><pre>                               <span class="keyword">if</span> (!log.match || log.match.test(lines[i]) || (match &amp;&amp; match.test(lines[i]))) {
                                   errors += lines[i] + <span class="string">"\n"</span>;
                               }
                           }</pre></div>
        
      
        
        <p>Separator between log files</p>

        
          <div class='highlight'><pre>                           <span class="keyword">if</span> (errors.length &gt; <span class="number">1</span>) errors += <span class="string">"\n\n"</span>;</pre></div>
        
      
        
        <p>Save current size to start next time from</p>

        
          <div class='highlight'><pre>                           db.query({ text: <span class="string">"REPLACE INTO backend_property VALUES(?,?,?)"</span>, values: [<span class="string">'logwatcher:'</span> + file, st.size, self.logwatcherMtime.toISOString()] }, <span class="function"><span class="keyword">function</span><span class="params">(e)</span> {</span>
                               <span class="keyword">if</span> (e) logger.error(<span class="string">'watchLogs:'</span>, file, e);
                               fs.close(fd, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>});
                               next();
                           });
                       });
                   });
                });
            }, <span class="function"><span class="keyword">function</span><span class="params">(err2)</span> {</span></pre></div>
        
      
        
        <p>Ignore possibly empty lines or cut off text</p>

        
          <div class='highlight'><pre>                <span class="keyword">if</span> (errors.length &gt; <span class="number">10</span>) {
                    logger.log(<span class="string">'logwatcher:'</span>, <span class="string">'found errors, send report to'</span>, self.logwatcherEmail);
                    self.sendmail(self.logwatcherFrom, self.logwatcherEmail, <span class="string">"logwatcher: "</span> + os.hostname() + <span class="string">"/"</span> + self.ipaddr + <span class="string">" errors"</span>, errors, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                        <span class="keyword">if</span> (callback) callback();
                    });
                } <span class="keyword">else</span> {
                    <span class="keyword">if</span> (callback) callback();
                }
            });
        });
    },

}

module.exports = core;</pre></div>
        
      
      <div class="fleur">h</div>
    </div>
  </div>
</body>
</html>
